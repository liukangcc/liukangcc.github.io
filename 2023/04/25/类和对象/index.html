

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Keaun">
  <meta name="keywords" content="">
  
    <meta name="description" content="类和对象在面向对象程序设计中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。 类的定义这里以时钟为例，时钟类的定义如下： 123456789class Clock&amp;#123;public：  void setrime(int newH; int newM; int news);  void showrime();private：  int hour, minute">
<meta property="og:type" content="article">
<meta property="og:title" content="类和对象">
<meta property="og:url" content="https://github.com/liukangcc/2023/04/25/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Keaun">
<meta property="og:description" content="类和对象在面向对象程序设计中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。 类的定义这里以时钟为例，时钟类的定义如下： 123456789class Clock&amp;#123;public：  void setrime(int newH; int newM; int news);  void showrime();private：  int hour, minute">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/img/favicon.png">
<meta property="article:published_time" content="2023-04-25T13:00:00.000Z">
<meta property="article:modified_time" content="2023-05-29T12:51:41.324Z">
<meta property="article:author" content="Keaun">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="class">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/img/favicon.png">
  
  
  
  <title>类和对象 - Keaun</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"github.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"★","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Keaun</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/Panes.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="类和对象"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-25 13:00" pubdate>
          2023年4月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          203 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">类和对象</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在面向对象程序设计中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>这里以时钟为例，时钟类的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>&#123;<br><br><span class="hljs-keyword">public</span>：<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setrime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH; <span class="hljs-type">int</span> newM; <span class="hljs-type">int</span> news)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showrime</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>：<br>  <span class="hljs-type">int</span> hour, minute, second;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里，封装了时钟的数据和行为，分别称为 Clock 类的数据成员和函数成员。定义类的语法形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 类名称<br>&#123;<br><br>   <span class="hljs-keyword">public</span>：<br>        外部接口<br><br>   <span class="hljs-keyword">protected</span>：<br>       保护型成员<br><br>   <span class="hljs-keyword">private</span>：<br>       私有成员<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p>访问控制属性可以有以下三种：公有类型（public）、私有类型（private）和保护类型（protected）</p>
<ol>
<li><p><strong>public</strong>： 成员定义了类的外部接口。公有成员用 public 关键字声明，在类外只能访问类的公有成员。对于时钟类，从外部只能调用 setTime()和 showTime()这两个公有类型的函数成员来改变或者查看时间。</p>
</li>
<li><p><strong>private</strong>：声明的就是类的 <strong>私有成员</strong>，如果私有成员紧接着类名称，则关键字 private 可以省略。<strong>私有成员只能被本类的成员函数访问</strong>，来自类外部的任何访问都是非法的。这样，私有成员就完全隐蔽在类中，保护了数据的安全性。时钟类中的 hour，minute，second 都是私有成员。</p>
</li>
<li><p><strong>protected</strong>：<strong>保护类型成员</strong> 的性质可以被其子类获得，但是不能通过类外访问得到。</p>
</li>
</ol>
<h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3><p>函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型，<strong>而函数的具体实现是写在类定义之外的</strong>。与普通函数不同的是，实现成员函数时要指明类的名称，具体形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 类名：：函数成员名（参数表）&#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clock::setTime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH,<span class="hljs-type">int</span> newM,<span class="hljs-type">int</span> newS)</span> </span>&#123;<br>   hour=newH;<br>   minute=newM;<br>   second=newS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clock::showTime</span><span class="hljs-params">()</span> </span>&#123;<br>   cout&lt;&lt;hour&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h4><p>函数的调用过程要消耗一些内存资源和运行时间来传递参数和返回值，要记录调用时的状态，以便保证调用完成后能够正确地返回并继续执行。如果有的函数成员需要被频繁调用，而且代码比较简单，这个函数也可以定义为内联函数（inline function）。和普通内联函数相同，内联成员函数的函数体也会在编译时被插入到每一个调用它的地方。这样做可以减少调用的开销，提高执行效率，但是却增加了编译后的代码长度。所以要在权衡利弊的基础上慎重选择，只有对相对简单的成员函数才可以声明为内联函数。</p>
<p>内联函数的声明有两种方式：<strong>隐式声明</strong> 和 <strong>显式声明</strong> 。</p>
<p>将函数体直接放在类体中，这种方法称之为隐式声明。比如，将时钟类的 showTime()函数声明为内联函数，可以写作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH,<span class="hljs-type">int</span> newM,<span class="hljs-type">int</span> newS)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showTime</span><span class="hljs-params">()</span></span>&#123;<br>            cout&lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt;endl;<br>      &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> hour,minute,second;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>为了保证类定义的简洁，可以采用关键字 inline 显式声明的方式。即在函数体实现时，在函数返回值类型前加上 inline，类定义时不加入 showTime 的函数体。请看下面的表达方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Clock::showTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt; &lt;hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>在定义对象时，可以同时对其数据成员赋初值，在定义对象时进行的数据成员设置，称为对象的初始化，在特定的对象使用结束时，需要进行一些清理工作，这里的初始化和清理工作分别由两个成员函数来完成，分别为 <strong>构造函数</strong> 和 <strong>析构函数</strong>。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数在对象被创建的时候将被自动调用。如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。如果类中声明了构造函数（无论是否有参数），编译器便不会再为之生成隐含的构造函数。</p>
<p>现将 Clock 类修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Clock</span>(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS);    <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetTime</span><span class="hljs-params">(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowTime</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> Hour,Minute,Second;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数的实现：</span><br>Clock::<span class="hljs-built_in">Clock</span>(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS)<br>&#123;<br>    Hour=NewH;<br>    Minute=NewM;<br>    Second=NewS;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面我们来看一看建立对象时构造函数的作用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Clock <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>    c.<span class="hljs-built_in">ShowTime</span>();<br>    c.<span class="hljs-built_in">SetTime</span>(<span class="hljs-number">8</span>,<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在建立对象 c 时，会隐含调用构造函数，将实参用作初始值。由于 Clock 类中定义了构造函数，所以编译系统就不会在为其生成默认构造函数了。而这里自定义的构造函数带有形参，所以建立对象就必须给出初始值，用来调用构造函数时的实参。</p>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用。其作用是使用一个已经存在的对象（由拷贝构造函数的参数指定），去初始化的一个新对象。</p>
<p>如果没有定义一个类的拷贝构造函数，系统会在必要时自动生成一个默认的拷贝构造函数（因为有一些操作是默认会调用拷贝构造函数），这个默认的拷贝构造函数的功能是，把初始化对象的每个数据成员的值都复制到新建立的对象中。</p>
<p>拷贝构造函数的例子：通过水平和垂直两个方向的坐标值 X 和 Y 来确定屏幕上的一个点。点（Point）类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-keyword">public</span>：<br>        <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx=<span class="hljs-number">0</span>,yy=<span class="hljs-number">0</span>)&#123;X=xx;Y=yy;&#125;<br>        <span class="hljs-built_in">Point</span>(Point&amp;p);<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> X;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> Y;&#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> X,Y;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>类中声明了内联构造函数函数和拷贝构造函数。拷贝构造函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point::<span class="hljs-built_in">Point</span>(Point &amp;p)<br>&#123;<br>    X = p.X;<br>    Y = p.Y;<br>    cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>普通拷贝构造函数是在对象创建时被调用，而拷贝构造函数在以下三种情况下都会被调用：</p>
<p>1、当用类的一个对象去初始化该类的另一个对象时。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> main（）&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>，<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;    <span class="hljs-comment">// 用对象 a 初始化对象 b，复制构造函数被调用</span><br>    Point c = a;   <span class="hljs-comment">// 用对象 a 初始化对象 c，复制构造函数被调用</span><br>    cout &lt;&lt; b.<span class="hljs-built_in">GetX</span>() &lt;&lt; end1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上对 b 和 c 的初始化都能够调用复制构造函数，两种写法只是形式上有所不同，执行的操作完全相同。</p>
<p>2、如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;p.<span class="hljs-built_in">GetX</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Point a（<span class="hljs-number">1</span>,<span class="hljs-number">2</span>）；<br>    <span class="hljs-built_in">f</span>(a);   <span class="hljs-comment">// 函数的形参为类的对象，当调用函数时，进行形参和实参结合时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>只有把对象用值传递时，才会调用复制构造函数，如果传递引用，则不会调用复制构造函数。由于这一原因，传递比较大的对象时，传递引用会比传值的效率高很多。</p>
<p>3、如果函数的返回值是类的对象，函数执行完成返回调用者时。 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Point <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> a;  <span class="hljs-comment">// 函数返回值是类的对象，返回函数值时，调用拷贝构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Point b;<br>    b = <span class="hljs-built_in">g</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么在这种情况下，返回函数值时，会调用复制构造函数呢？</p>
<p>a 其实是一个局部变量，在 g()执行完后，就会被释放。执行语句 <strong>return a;</strong> 时，实际上是调用复制构造函数将 a 的值复制到临时对象中。</p>
<h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><ol>
<li>只有构造函数才可以使用初始化列表，其他函数使用会报错：only constructors take member initializers</li>
</ol>
<p>构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。</p>
<p>构造函数的初始化列表使得代码更加简洁，请看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *m_name;<br>    <span class="hljs-type">int</span> m_age;<br>    <span class="hljs-type">float</span> m_score;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 采用初始化列表</span><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score)&#123;<br> <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::show</span><span class="hljs-params">()</span></span>&#123;<br>   cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot;的年龄是&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="hljs-string">&quot;，成绩是&quot;</span>&lt;&lt; m_score &lt;&lt; <span class="hljs-built_in">show</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">小明的年龄是 15，成绩是 92.5<br>李华的年龄是 16，成绩是 96<br></code></pre></td></tr></table></figure>

<p>如本例所示，定义构造函数时并没有在函数体中对成员变量一一赋值，其函数体为空（当然也可以有其他语句），而是在函数首部与函数体之间添加了一个冒号:，后面紧跟 m_name(name), m_age(age), m_score(score) 语句，这个语句的意思相当于函数体内部的 <code>m_name = name; m_age = age; m_score = score;</code> 语句，也是赋值的意思。</p>
<p>使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。</p>
<p>初始化列表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用初始化列表，其他成员变量还是一一赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name)&#123;<br>    m_age = age;<br>    m_score = score;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。请看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CCar</span> &#123; <br>    cout&lt;&lt;m_a&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;m_b&lt; “封闭类” <br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> price;<br>        CTyre tyre;<br>        CEngine engine;<br><br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">CCar</span>(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> tr, <span class="hljs-type">int</span> tw); <br>&#125;; <br><br>CCar::<span class="hljs-built_in">CCar</span>(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> tr, <span class="hljs-type">int</span> w): <span class="hljs-built_in">price</span>(p), <span class="hljs-built_in">tyre</span>(tr, w) &#123;<br><br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br><br>    <span class="hljs-function">CCar <span class="hljs-title">car</span><span class="hljs-params">(<span class="hljs-number">20000</span>,<span class="hljs-number">17</span>,<span class="hljs-number">225</span>)</span></span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 CCar 类不定义构造函数，则 CCar car；会编译错误</p>
<ol>
<li><p>编译器不知道 car.tyre 如何初始化</p>
</li>
<li><p>car.engine 的初始化没有问题: 用默认构造函数</p>
</li>
</ol>
<p>所有要明确告诉 “对象中的成员对象”如何初始化？</p>
<p>定义封闭类的构造函数时, 添加初始化列表:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名:: 构造函数(参数表): 成员变量 <span class="hljs-number">1</span>(参数表), 成员变量 <span class="hljs-number">2</span>(参数表), …<br>&#123;<br>    …<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数与构造函数的作用几乎正好相反，它用来完成对象被删除前的一些清理工作，例如释放分配的内存、关闭打开的文件等。析构函数是在对象的生存期即将结束的时刻被自动调用的。</p>
<p>析构函数没有参数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~ 符号。</p>
<h3 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h3><p>我们知道 C++ 的类应当是先定义，然后使用。但在处理相对复杂的问题、考虑类的组合时，很可能遇到俩个类相互引用的情况，这种情况称为循环依赖。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B b)</span></span>;<span class="hljs-comment">// 以 B 类对象 b 为形参的成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(A a)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里类 A 的公有成员函数 f 的形参是类 B 的对象，同时类 B 的公有成员函数 g 也以类 A 的对象为形参。由于在使用一个类之前，必须首先定义该类，因此无论将哪一个类的定义放在前面，都会引起编译错误。结局这个问题的方法，就是使用前向引用声明。前向引用声明，是在引用未定义的类之前，将该类的名字告诉编译器，试编译器知道那是一个类名。这样，当程序中使用这个类名时，编译器就不会认为是错误，而类的完整定义可以在程序的其他地方。在上述程序加上下面的前向引用声明，问题就解决了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向引用声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><span class="hljs-comment">//A 类的定义</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">// 外部接口</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B b)</span></span>;<span class="hljs-comment">// 以 B 类对象 b 为形参的成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><span class="hljs-comment">//B 类的定义</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">// 外部接口</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(A a)</span></span>;<span class="hljs-comment">// 以 A 类对象 a 为形参的成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>静态成员是解决同一个类的不同对象之间数据和函数共享问题的。</p>
<h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><ol>
<li><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，该 static 成员也只会有一个，某个对象修改了这个 static 成员，其他对象也会受到影响；</p>
</li>
<li><p>一般的用法 <strong>类名 :: 标识符</strong></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span> *m_name;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-type">float</span> m_score;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_total; <span class="hljs-comment">// 声明静态成员，此时并未分配内存空间给 m_total</span><br>&#125;;<br><br><span class="hljs-type">int</span> Student::m_total = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义并初始化静态成员 m_total，此时分配内存空间</span><br><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score) : <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score) &#123;<br>    m_total++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] name: %s, age: %d, score: %g\n&quot;</span>, m_total, m_name, m_age, m_score);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>)</span></span>;<br>    s1.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>)</span></span>;<br>    s2.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">33</span>)</span></span>;<br>    s3.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[1] name: A, age: 1, score: 11<br>[2] name: B, age: 2, score: 22<br>[3] name: C, age: 3, score: 33<br></code></pre></td></tr></table></figure>


<h4 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h4><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_cnt</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title">get_sum</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_cnt;<br>        <span class="hljs-type">static</span> <span class="hljs-type">float</span> m_sum;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* m_name;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-type">float</span> m_score;<br>&#125;;<br><br><span class="hljs-type">int</span> Student::m_cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">float</span> Student::m_sum = <span class="hljs-number">0.0f</span>;<br><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score) &#123;<br><br>   m_cnt++;<br><br>   m_sum += score;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::print</span><span class="hljs-params">()</span> </span>&#123;<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s, age: %d, score: %g\n&quot;</span>, m_name, m_age, m_score);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::get_cnt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// return m_age; 静态函数掉用普通成员，编译错误。</span><br>    <span class="hljs-comment">// error: invalid use of member &#x27;Student::m_age&#x27; in static member function</span><br>    <span class="hljs-keyword">return</span> m_cnt; <span class="hljs-comment">/* 可以访问静态成员 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Student::get_sum</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>)</span></span>;<br>    s1.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>)</span></span>;<br>    s2.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">33</span>)</span></span>;<br>    s3.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_total: %d, score_total: %g\n&quot;</span>, Student::<span class="hljs-built_in">get_cnt</span>(), Student::<span class="hljs-built_in">get_sum</span>());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: A, age: 1, score: 11<br>name: B, age: 2, score: 22<br>name: C, age: 3, score: 33<br>student_total: 3, score_total: 66<br></code></pre></td></tr></table></figure>

<h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h3><p>默认情况下，c++ 编译器至少给一个类添加 3 个函数</p>
<ol>
<li><p>默认构造函数（无参，函数体为空）</p>
</li>
<li><p>默认析构函数（无参，函数体为空）</p>
</li>
<li><p>默认拷贝构造函数，对属性进行拷贝</p>
</li>
</ol>
<p>构造函数的调用规则如下：</p>
<ol>
<li><p>如果用户定义了有参构造函数，c++ 不在提供默认无参构造函数，但是会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义了拷贝构造函数，c++ 不在提供其他构造函数</p>
</li>
</ol>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作<br>深拷贝：在堆区重新申请空间，进行拷贝操作；</p>
<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><h2 id="对象模型和-this-指针"><a href="#对象模型和-this-指针" class="headerlink" title="对象模型和 this 指针"></a>对象模型和 this 指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><p>c++ 编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置。每个空对象也应该有一个独一无二的内存地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure>

<h4 id="非静态成员变量"><a href="#非静态成员变量" class="headerlink" title="非静态成员变量"></a>非静态成员变量</h4><p>属于类对象上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 4<br></code></pre></td></tr></table></figure>

<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>不属于类对象上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::a = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure>

<h4 id="非静态成员函数"><a href="#非静态成员函数" class="headerlink" title="非静态成员函数"></a>非静态成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure>

<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::a</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>  Person p;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出：<br><br>```shell<br>size of p = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol>
<li><p>指向被调用的成员函数所属的对象</p>
</li>
<li><p>隐含每一个非静态成员函数内的一种指针</p>
</li>
<li><p>不需要定义，直接使用即可</p>
</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li><p>当形参和成员变量同名时，可用 this 指针来区分</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用 return *this</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<span class="hljs-keyword">this</span>-&gt;age = age;&#125; <span class="hljs-comment">/* 用途 1 */</span><br><br>        <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(Person &amp;p)</span>   <span class="hljs-comment">/* 用途 2 */</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>            <span class="hljs-comment">/* 返回对象本身 */</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">/* 链式编程思想 */</span><br>    p2.<span class="hljs-built_in">PersonAgeAdd</span>(p1).<span class="hljs-built_in">PersonAgeAdd</span>(p1).<span class="hljs-built_in">PersonAgeAdd</span>(p1);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p2.age:&quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>c++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针。如果用到 this 指针，需要加以判断保证代码的健壮性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">使用空指针访问类的成员函数和成员变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPersonAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//    if (this == nullptr) &#123;</span><br>        <span class="hljs-comment">//      return;</span><br>        <span class="hljs-comment">//    &#125;</span><br>             std::cout &lt;&lt; <span class="hljs-string">&quot;age=&quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person *p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">showClassName</span>(); <span class="hljs-comment">/* 可以访问成员函数 */</span><br>    p-&gt;<span class="hljs-built_in">showPersonAge</span>(); <span class="hljs-comment">/* 不能访问成员变量 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, world!<br><br>age=<br><br>Process finished with exit code -1073741819 (0xC0000005)<br></code></pre></td></tr></table></figure>

<p> 当上面的测试用例在访问类的属性时，代码异常退出。可以取消注释代码，增强程序的健壮性。</p>
<h2 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h2><h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><ol>
<li><p>成员函数后加 const 后我们称这个函数为常函数</p>
</li>
<li><p>常函数内不可以修改成员属性</p>
</li>
<li><p>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改</p>
</li>
</ol>
<h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ol>
<li><p>声明对象前加 const 称对象为常对象</p>
</li>
<li><p>常对象只能调用常函数</p>
</li>
</ol>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>             std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-comment">/* this 指针的本质是指针常量， 指针的指向不可以修改</span><br><span class="hljs-comment">        \* const Person* const this</span><br><span class="hljs-comment">        \* */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">/* 常函数 */</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-comment">//    this-&gt;m_age = 19; /* 不可以修改 */</span><br>             <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">20</span>;   <span class="hljs-comment">/* 使用 mutable 修饰，可以修改 */</span><br>        &#125;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> Person p; <span class="hljs-comment">/* 常对象 */</span><br>    <span class="hljs-comment">//p.m_age = 10; /* 不可以修改 */</span><br>    p.m_B = <span class="hljs-number">10</span>; <span class="hljs-comment">/* 可以修改 */</span><br>    <span class="hljs-comment">/* 常对象只能调用常函数 */</span><br>    p.<span class="hljs-built_in">hello</span>(); <span class="hljs-comment">/* 不可以访问 */</span><br>    p.<span class="hljs-built_in">showAge</span>(); <span class="hljs-comment">/* 可以访问 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里面，有些私有属性也想让类外特殊的一些函数或者类进行访问</p>
<p>友元的关键词为 friend</p>
<p>友元的三种实现</p>
<ol>
<li><p>全局函数做友元</p>
</li>
<li><p>类做友元</p>
</li>
<li><p>成员函数做友元</p>
</li>
</ol>
<h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>一个函数可以访问一个类中的私有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><br>    <span class="hljs-comment">/* goodGay 全局函数是 Building 的友元函数, 可以访问 Building 中私有成员 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building *building)</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>() &#123;<br>             m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>             m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>        &#125;<br><br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br><span class="hljs-comment">/* 友元函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building *building)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;now:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Building building;<br>    <span class="hljs-built_in">goodGay</span>(&amp;building);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">now: woshi<br></code></pre></td></tr></table></figure>

<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p>一个类可以访问另外一个类中的私有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> ;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br><br>  Building *building;<br><br>  <span class="hljs-built_in">GoodGay</span>();<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span>; <span class="hljs-comment">/* 友元类 */</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>();<br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>    m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>&#125;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay goodGay;<br>    goodGay.<span class="hljs-built_in">visit</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">woshi<br></code></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> ;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br>        Building *building;<br>        <span class="hljs-built_in">GoodGay</span>();<br>        ~<span class="hljs-built_in">GoodGay</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>();<br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>    m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>&#125;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br>GoodGay::~<span class="hljs-built_in">GoodGay</span>() &#123;<br>    <span class="hljs-keyword">if</span> (building) &#123;<br>         <span class="hljs-keyword">delete</span> building;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 不可访问私有成员 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; <span class="hljs-comment">/* 编译报错 */</span><br>&#125;<br><br><span class="hljs-comment">/* 成员函数作为友元，可以访问类中的私有成员 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit1</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay goodGay;<br>    goodGay.<span class="hljs-built_in">visit</span>();<br>    goodGay.<span class="hljs-built_in">visit1</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为[派生类](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item">https://baike.baidu.com/item</a> &#x2F; 派生类 &#x2F; 9589520?fromModule&#x3D;lemma_inlink)，又称为子类。</p>
<p>class A: public&#x2F;private&#x2F;protected B;</p>
<ol>
<li><p>A 称为子类或者派生类</p>
</li>
<li><p>B 称为父类或者基类</p>
</li>
</ol>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法：class 子类： 继承方式 父类 </p>
<ol>
<li><p>公共继承</p>
</li>
<li><p>保护继承</p>
</li>
<li><p>私有继承</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a;<br>    <br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>: <span class="hljs-keyword">public</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//    c = 30; 父类中的私有成员，公有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">protected</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//     c = 30; 父类中的私有成员，公有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">private</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//    c = 30; 父类中的私有成员，私有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    A A1;<br><br>    A1.a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 父类中的公有成员，公有继承后变为公有成员，类外可以访问</span><br>    <span class="hljs-comment">//  A1.b = 20; 父类中的保护成员，公有继承后依然为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  A1.c = 30; 父类中的私有成员，公有继承无法访问</span><br><br>    B B1;<br>    <span class="hljs-comment">//  B1.a = 20; 父类中的公有成员，保护继承后变为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  B1.b = 20; 父类中的保护成员，保护继承后依然为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  B1.c = 20; 父类中的私有成员，公有继承无法访问</span><br><br>    C C1;<br>    <span class="hljs-comment">//  C1.a = 10; 父类中的公有成员，私有继承后变为私有成员，类外无法访问</span><br>    <span class="hljs-comment">//  C1.b = 10; 父类中的保护成员，私有继承后变为私有成员，类外无法访问</span><br>    <span class="hljs-comment">//  C2.c = 10; 父类中的私有成员，私有继承后变为私有成员，类外无法访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-built_in">test01</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><ol>
<li><p>在父类中所有非静态成员属性都有会被子类继承下去</p>
</li>
<li><p>父类中私有的成员属性是被编译器给隐藏了，因此访问不到，但是还是会被子类继承下去</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a;<br><br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> c;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> d;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Father) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">12<br><br>16<br></code></pre></td></tr></table></figure>

<h3 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h3><ol>
<li><p>父类的构造函数</p>
</li>
<li><p>子类的构造函数</p>
</li>
<li><p>子类的析构函数</p>
</li>
<li><p>父类的析构函数</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Father</span>();<br>        ~<span class="hljs-built_in">Father</span>();<br>&#125;;<br><br>Father::<span class="hljs-built_in">Father</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Father::Father&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Father::~<span class="hljs-built_in">Father</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Father::~Father&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Son</span>();<br>        ~<span class="hljs-built_in">Son</span>();<br>&#125;;<br><br>Son::<span class="hljs-built_in">Son</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son::Son&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Son::~<span class="hljs-built_in">Son</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son::~Son&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son s1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Father::Father<br><br>Son::Son<br><br>Son::~Son<br><br>Father::~Father<br></code></pre></td></tr></table></figure>

<h3 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式"></a>继承中同名成员处理方式</h3><ol>
<li><p>访问子类同名成员时，直接访问即可</p>
</li>
<li><p>访问父类同名成员时，需要加作用域</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;father::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">100</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">200</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son s1;<br><br>    s1.<span class="hljs-built_in">printf</span>();<br>    s1.Father::<span class="hljs-built_in">printf</span>();             <span class="hljs-comment">/* 访问父类中的同名成员函数时，需要加作用域 */</span><br>    cout &lt;&lt; s1.m &lt;&lt; endl;<br>    cout &lt;&lt; s1.Father::m &lt;&lt; endl;   <span class="hljs-comment">/* 访问父类中的同名成员属性时，需要加作用域 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">son::printf<br>father::printf<br>200<br>100<br></code></pre></td></tr></table></figure>

<h3 id="继承中同名静态成员处理方式"><a href="#继承中同名静态成员处理方式" class="headerlink" title="继承中同名静态成员处理方式"></a>继承中同名静态成员处理方式</h3><p>静态成员：</p>
<ol>
<li><p>静态成员函数只能访问静态成员变量</p>
</li>
<li><p>静态成员属性：类内声明，类外初始化</p>
</li>
</ol>
<p>访问方式：</p>
<ol>
<li><p>通过对象访问</p>
</li>
<li><p>通过类名访问</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;father::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m;<br>&#125;;<br><br><span class="hljs-type">int</span> Father::m = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m = <span class="hljs-number">200</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Son s1;<br><br>    <span class="hljs-comment">// 通过对象访问</span><br>    s1.<span class="hljs-built_in">printf</span>();<br>    s1.Father::<span class="hljs-built_in">printf</span>();<br>    <span class="hljs-comment">// 通过类名访问</span><br>    Son::<span class="hljs-built_in">printf</span>();<br>    Son::Father::<span class="hljs-built_in">printf</span>();<br>    <span class="hljs-comment">// 通过对象访问</span><br>    cout &lt;&lt; s1.m &lt;&lt; endl;<br>    cout &lt;&lt; s1.Father::m &lt;&lt; endl;<br>    <span class="hljs-comment">// 通过类名访问</span><br>    cout &lt;&lt; Son::m &lt;&lt; endl;<br>    cout &lt;&lt; Son::Father::m &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">son::printf<br>father::printf<br>son::printf<br>father::printf<br>200<br>100<br>200<br>100<br></code></pre></td></tr></table></figure>

<h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>首先：强调一个概念</p>
<ol>
<li><p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
</li>
<li><p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p>
</li>
<li><p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
</li>
</ol>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    a-&gt;<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 在这里，a 虽然是指向 A 的指针，但是被调用的函数 (foo) 却是 B 的!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">B::foo() is called<br></code></pre></td></tr></table></figure>

<p>虽然 a 指向了 class A，但是调用的是 class B 中的 foo()</p>
<h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>语法：class 子类：继承方式 父类 1, 继承方式 父类 2 … </p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++ 开发中不建议使用多继承语法开发</strong></p>
<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol>
<li><p>两个派生类继承同一个基类</p>
</li>
<li><p>又有某个类同时继承两个派生类</p>
</li>
<li><p>这种继承被称为菱形继承，或者钻石分类</p>
</li>
</ol>
<h4 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h4><ol>
<li><p>羊继承了动物的数据，驼继承了动物的数据，当羊驼继承时，会产生二义性。</p>
</li>
<li><p>羊驼继承自动物的数据继承了两份</p>
</li>
</ol>
<p>第一种问题可以使用作用域解决；</p>
<p>第二种问题可以使用虚继承解决；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">/* 加 virtual 关键字，表示虚继承 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><br>&#125;;<br><br><span class="hljs-comment">/* 加 virtual 关键字，表示虚继承 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span>: <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    SheepTuo t1;<br>    <span class="hljs-comment">//  t1.m_Age = 100; 继承了两份，产生二义性</span><br>    <span class="hljs-comment">// 当两个父类拥有相同的数据，需要加以作用域区分</span><br>    t1.Sheep::m_Age = <span class="hljs-number">100</span>;<br>    t1.Tuo::m_Age = <span class="hljs-number">200</span>;<br>    <span class="hljs-comment">//  菱形继承导致了数据有两份，造成资源浪费，使用虚继承，保证 m_Age 只有一份</span><br>    cout &lt;&lt; t1.Sheep::m_Age &lt;&lt; endl; <span class="hljs-comment">//vbptr, 虚拟指针指向 t1.m_Age </span><br>    cout &lt;&lt; t1.Tuo::m_Age &lt;&lt; endl;   <br>    cout &lt;&lt; t1.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>关键字：virtual </p>
<h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>多态分为两类：</p>
<ul>
<li><p>静态多态：函数重载、运算符重载属于静态多态，复用函数名</p>
</li>
<li><p>动态多态：派生类和虚函数实现运行时多态</p>
</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li><p>静态多态的函数地址早绑定：编译阶段时确定函数地址</p>
</li>
<li><p>动态多态的韩式地址晚绑定：运行阶段时确定函数地址</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/* 虚函数 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;animal is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;cat is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;dog is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 动态多态的使用 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak_func</span><span class="hljs-params">(Animal &amp;animal)</span> </span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Cat cat;<br>    Dog dog;<br><br>    <span class="hljs-built_in">speak_func</span>(cat);<br>    <span class="hljs-built_in">speak_func</span>(dog);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat is speaking<br>dog is speaking<br></code></pre></td></tr></table></figure>

<p>动态多态满足条件：</p>
<ol>
<li><p>有继承关系</p>
</li>
<li><p>子类重写父类的虚函数</p>
</li>
</ol>
<p>动态多态的使用：</p>
<ol>
<li>父类的指针或者引用指向子类对象</li>
</ol>
<p>多态带来的好处：</p>
<ol>
<li><p>组织结构清晰</p>
</li>
<li><p>可读性强</p>
</li>
</ol>
<p>重写：函数返回值类型，函数名，入参完全一致</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">虚函数表</a></p>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的</p>
<p>纯虚函数语法：virtaul 返回值类型 函数名(参数列表) &#x3D; 0；</p>
<p>当类中有了纯虚函数，这个类也成为抽象类</p>
<p>抽象类的特点：</p>
<ol>
<li><p>无法实例化对象</p>
</li>
<li><p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* 抽象类：含有纯虚函数的类。纯虚函数：virtual 返回值类型 函数名（参数）= 0;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son func&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>: <span class="hljs-keyword">public</span> Base &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//  Base base; 报错: 抽象类无法实例化对象</span><br>    <span class="hljs-comment">//  new Base; 报错: 抽象类无法实例化对象</span><br>    <span class="hljs-comment">//  Son2 son2; 报错: 抽象类的子类必须重写父类中的纯虚函数, 否则还是抽象类</span><br>    Base *base = <span class="hljs-keyword">new</span> Son; <span class="hljs-comment">/* 编译正常， 运行正常 */</span><br>    base-&gt;<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">delete</span> base;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。</p>
<p>纯虚析构：需要声明也需要实现。</p>
<p>解决方法：将父类中的析构函数改为虚析构或者纯虚析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">Animal</span>() &#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Animal::Animal&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() &#123; <span class="hljs-comment">/* 父类的析构函数为虚函数时，父类指针在析构时才会调用子类的析构函数 */</span><br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Animal::~Animal&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Sheep</span>(std::string name);<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    std::string *hello = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>        ​    cout &lt;&lt; *name &lt;&lt; <span class="hljs-string">&quot;Sheep is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        ~<span class="hljs-built_in">Sheep</span>() &#123;<br>        ​    <span class="hljs-keyword">if</span> (name) &#123;<br>        ​      <span class="hljs-keyword">delete</span> name;<br>        ​      name = <span class="hljs-literal">nullptr</span>;<br>        ​    &#125;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Sheep::~Sheep&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        string *name = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br>Sheep::<span class="hljs-built_in">Sheep</span>(std::string name) &#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sheep::Sheep&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Animal *sheep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Sheep</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    sheep-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> sheep;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>### 多态案例： 计算器类<br><br>分别使用普通写法和多态技术，设计实现两个操作数进行运算的计算器类<br><br>```c++<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* 多态案例一：实现计算器类</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* 普通写法 */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorNoraml</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    ​    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span> </span>&#123;<br>    ​      <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>    ​        <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>    ​      &#125;<br><br>    ​      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>    ​        <span class="hljs-built_in">return</span> (m_Num1 &gt; m_Num2)? (m_Num1 - m_Num2) : (m_Num2 - m_Num1);<br>    ​      &#125;<br>    ​      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//      如果想扩展新的功能，需要修改源码</span><br>    <span class="hljs-comment">//      在真正开发中，提倡开闭原则: 对扩展进行开放, 对修改进行关闭</span><br>    ​    &#125;<br><br>    ​    <span class="hljs-type">int</span> m_Num1; <span class="hljs-comment">// 操作数一</span><br>    ​    <span class="hljs-type">int</span> m_Num2; <span class="hljs-comment">// 操作数二</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>  CalculatorNoraml test1;<br><br>  test1.m_Num1 = <span class="hljs-number">10</span>;<br>  test1.m_Num2 = <span class="hljs-number">8</span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;normal +:&quot;</span> &lt;&lt; test1.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;normal -:&quot;</span> &lt;&lt; test1.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/* 多态写法 */</span><br><br><span class="hljs-comment">// 实现计算器的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorAbstract</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">// 实现加法类, 继承自基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>: <span class="hljs-keyword">public</span> CalculatorAbstract &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> m_Num2 + m_Num1;<br>        &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实现减法类, 继承自基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span>: <span class="hljs-keyword">public</span> CalculatorAbstract &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> (m_Num1 &gt; m_Num2)? (m_Num1 - m_Num2) : (m_Num2 - m_Num1);<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">/* 多态使用条件</span><br><span class="hljs-comment">    \* 父类指针或者引用指向子类对象</span><br><span class="hljs-comment">    \* */</span><br><br>    <span class="hljs-comment">// 加法运算</span><br>    CalculatorAbstract * abc = <span class="hljs-keyword">new</span> Add;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;abstract +:&quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br><br>    abc = <span class="hljs-keyword">new</span> Sub;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;abstract -:&quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">normal +: 18<br>normal -:2<br>abstract +: 18<br>abstract -: 2<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/">#c++</a>
      
        <a href="/tags/class/">#class</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>类和对象</div>
      <div>https://github.com/liukangcc/2023/04/25/类和对象/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Keaun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/29/STL/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/09/01/rust%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" title="Rust代码 嵌入到 rt-thread">
                        <span class="hidden-mobile">Rust代码 嵌入到 rt-thread</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'liukangcc/liukangcc.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
