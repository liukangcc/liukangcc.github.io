<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rt-thread 内存管理模块之小内存管理算法</title>
    <link href="/2023/05/29/rt-thread%20%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%971/"/>
    <url>/2023/05/29/rt-thread%20%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%971/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在 rt-thread 操作系统中存在这几大模块，分别为：线程调度模块、线程间通信模块、线程间同步模块、内存管理模块、文件系统模块以及网络接口模块。<br>本次我们来了解一下 rt-thread 操作系统中对于内存是如何进行管理的。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RT-Thread 是一个实时操作系统，为了适应嵌入式设备的资源限制，它提供了多个小内存管理算法。这些算法旨在高效地管理小块内存，并尽可能减少内存碎片的产生。</p><h2 id="内存堆"><a href="#内存堆" class="headerlink" title="内存堆"></a>内存堆</h2><p>内存堆（Memory Heap）是计算机内存中一块动态分配的内存区域，用于存储程序运行时动态分配的数据。在大多数编程语言中，包括C、C++、Java等，内存堆用于存储动态分配的对象和数据结构，这些对象在程序运行时动态创建和销毁。  </p><p>内存堆的主要特点是动态分配和释放内存空间，不同于静态分配的内存（如全局变量和局部变量）。程序可以使用堆上的内存来存储灵活大小的数据，根据需要进行动态的内存分配和释放。这使得程序能够在运行时根据需求来管理内存，并避免静态内存分配的限制。</p><p>在使用内存堆时，程序员通常使用特定的堆分配函数（如malloc、new等）来请求所需大小的内存块。当不再需要这些内存块时，应使用相应的堆释放函数（如free、delete等）将其释放回堆，以避免内存泄漏。<br>需要注意的是，对内存堆的不当使用可能导致内存泄漏、内存碎片等问题，因此在使用堆分配的内存时应谨慎管理和释放内存。</p><p>综上所述：内存堆是一块动态分配的内存区域，用于存储程序运行时动态分配的数据。程序可以使用堆上的内存来存储灵活大小的数据，并通过堆分配函数和堆释放函数来管理内存的分配和释放。<br>在 RT-Thread 操作系统中，动态内存堆的管理根据使用场景分为三种：</p><ul><li>small memory 管理算法：适用于小内存块的管理算法</li><li>slab memroy 管理算法：适用于大内存块的管理算法</li><li>memheap memory 管理算法：适用于多内存块的管理算法</li></ul><p>本次先来了解一下 small memory 管理算法。通过对整体源码的解读，由浅入深，加深对于 rt-thread 操作系统中内存管理模块的理解。</p><h2 id="small-memory"><a href="#small-memory" class="headerlink" title="small memory"></a>small memory</h2><p>小内存管理算法是一个简单的内存分配算法。初始时，它是一块大的内存。当需要分配内存块时，将从这个大的内存块上分割出相匹配的内存块，然后把分割出来的空闲内存块还回给堆管理系统中。每个内存块都包含一个管理用的数据头，通过这个头把使用块与空闲块用双向链表的方式链接起来。注意：这里的链表存放的并不是数据头绝对地址，而是相对于开始地址的偏移量。在下面的源码解析中会进行详细的说明。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在小内存管理算法中，主要使用了下面的数据结构：</p><h4 id="小内存模块的内存头"><a href="#小内存模块的内存头" class="headerlink" title="小内存模块的内存头"></a>小内存模块的内存头</h4><p>在小内存管理算法中，每一块内存块都会有一个内存头，内存头的数据结构如下：</p><p><img src="https://files.mdnice.com/user/44140/cd02a0f3-7508-43f4-834d-d855c9324a39.png"></p><p>参数解析：  </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pool_ptr</td><td>small memory object addr</td></tr><tr><td>next</td><td>next free item</td></tr><tr><td>prev</td><td>prev free item</td></tr></tbody></table><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>rt-thread 操作系统内存管理的基本数据结构：</p><p><img src="https://files.mdnice.com/user/44140/20ffb762-873f-45c2-99d5-ec36d963aba1.png"></p><p>参数解析：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>parent</td><td>inherit from rt_object</td></tr><tr><td>algorithm</td><td>memory management algorithm name</td></tr><tr><td>address</td><td>memory start address</td></tr><tr><td>total</td><td>memory size</td></tr><tr><td>used</td><td>size used</td></tr><tr><td>max</td><td>maximum usage</td></tr></tbody></table><h4 id="小内存模块对象的基本结构"><a href="#小内存模块对象的基本结构" class="headerlink" title="小内存模块对象的基本结构"></a>小内存模块对象的基本结构</h4><p>在小内存管理算法中，存在的唯一一个模块对象：</p><p><img src="https://files.mdnice.com/user/44140/687d0768-7c2e-43c2-ab27-c65a651a6d8f.png"></p><p>参数解析：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>parent</td><td>inherit from rt_memory</td></tr><tr><td>heap_ptr</td><td>pointer to the heap</td></tr><tr><td>heap_end</td><td>pointer to the heap end address</td></tr><tr><td>lfree</td><td>pointer to free memory list</td></tr><tr><td>mem_size_aligned</td><td>aligned memory size</td></tr></tbody></table><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>在观看源码的之前，先来了解两个字节对齐的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN(size, align)           (((size) + (align) - 1) &amp; ~((align) - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RT_ALIGN_DOWN(size, align)      ((size) &amp; ~((align) - 1))</span><br></code></pre></td></tr></table></figure><ol><li>RT_ALIGN：在 size 的基础上向上对齐，对齐后的值为 align 的倍数。RT_ALIGN(13, 4)，对齐后的值为：16</li><li>RT_ALIGN_DOWN： 在 size 的基础上向下对齐，对齐后的值为 align 的倍数。RT_ALIGN_DOWN(13, 4)， 对齐后的值为：12</li></ol><p>为什么要在嵌入式系统中进行字节对齐操作，以下是几个主要原因：</p><ol><li>访问效率：许多嵌入式系统使用总线来访问内存，而总线通常是按照字节为单位进行传输的。如果数据结构没有进行字节对齐，例如一个2字节的数据结构放置在奇数地址上，那么在访问这个数据结构时就需要进行两次内存访问操作。而如果数据结构进行了字节对齐，将其放置在合适的地址上，可以减少内存访问次数，提高数据的读取效率。</li><li>CPU对齐要求：许多CPU架构对于某些数据类型有对齐要求。如果数据没有按照要求对齐，可能会导致性能下降或者引发硬件异常。通过字节对齐操作，确保数据结构满足CPU的对齐要求，可以避免潜在的问题。</li><li>数据可靠性：在多字节数据类型（如整型、浮点型等）的读写操作中，如果数据没有按照对齐要求存放，可能会引发未定义的行为。例如，某些CPU要求访问4字节整型数据时，其地址必须是4的倍数。如果数据没有进行对齐，读写操作可能会跨越多个字节的边界，导致数据错误或者异常。</li><li>数据结构互操作性：在嵌入式系统中，可能会涉及到不同硬件模块或通信协议之间的数据交互。这些硬件或协议往往有特定的数据对齐要求。通过对数据进行字节对齐操作，可以确保数据在不同模块之间的正确传输和解析，提高数据的互操作性。</li></ol><h3 id="plug-holes"><a href="#plug-holes" class="headerlink" title="plug_holes"></a>plug_holes</h3><p>合并相邻的内存块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">plug_holes</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rt_small_mem *m, <span class="hljs-keyword">struct</span> rt_small_mem_item *mem)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">nmem</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">pmem</span>;</span><br><br>    RT_ASSERT((<span class="hljs-type">rt_uint8_t</span> *)mem &gt;= m-&gt;heap_ptr);<br>    RT_ASSERT((<span class="hljs-type">rt_uint8_t</span> *)mem &lt; (<span class="hljs-type">rt_uint8_t</span> *)m-&gt;heap_end);<br><br>    <span class="hljs-comment">/* 判断 mem 的下一块内存块是否可以合并 */</span><br>    nmem = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;m-&gt;heap_ptr[mem-&gt;next];<br>    <span class="hljs-keyword">if</span> (mem != nmem &amp;&amp; !MEM_ISUSED(nmem) &amp;&amp;<br>        (<span class="hljs-type">rt_uint8_t</span> *)nmem != (<span class="hljs-type">rt_uint8_t</span> *)m-&gt;heap_end)<br>    &#123;<br>        <span class="hljs-comment">/* 如果 mem-&gt;next 没有被使用，合并 mem 和 mem-&gt;next */</span><br>        <span class="hljs-keyword">if</span> (m-&gt;lfree == nmem)<br>        &#123;<br>            m-&gt;lfree = mem;<br>        &#125;<br>        nmem-&gt;pool_ptr = <span class="hljs-number">0</span>;<br>        mem-&gt;next = nmem-&gt;next;<br>        ((<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;m-&gt;heap_ptr[nmem-&gt;next])-&gt;prev = (<span class="hljs-type">rt_uint8_t</span> *)mem - m-&gt;heap_ptr;<br>    &#125;<br><br>    <span class="hljs-comment">/* 判断 mem 的上一块内存块是否可以合并 */</span><br>    pmem = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;m-&gt;heap_ptr[mem-&gt;prev];<br>    <span class="hljs-keyword">if</span> (pmem != mem &amp;&amp; !MEM_ISUSED(pmem))<br>    &#123;<br>        <span class="hljs-comment">/* 如果 mem-&gt;prev 没有被使用，合并 mem 和 mem-&gt;prev */</span><br>        <span class="hljs-keyword">if</span> (m-&gt;lfree == mem)<br>        &#123;<br>            m-&gt;lfree = pmem;<br>        &#125;<br>        mem-&gt;pool_ptr = <span class="hljs-number">0</span>;<br>        pmem-&gt;next = mem-&gt;next;<br>        ((<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;m-&gt;heap_ptr[mem-&gt;next])-&gt;prev = (<span class="hljs-type">rt_uint8_t</span> *)pmem - m-&gt;heap_ptr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的作用是将相邻空闲内存块进行合并；有以下两种情况：</p><ol><li>mem 的下一块内存块为空闲内存块，并且不是内存堆结束数据头；如果此时 lfree 指向了 nmem，需要修改 lfree 指向 mem；可以用下面的图来描述：</li></ol><p><img src="https://files.mdnice.com/user/44140/0ff9e7e2-590f-44c5-850c-c0ac1d553107.png"></p><ol start="2"><li>mem 的上一块内存块为空闲内存块；如果此时 lfree 指向了 mem，需要修改 lfree 的指向；该合并内存块操作可以用如下如图片来描述：</li></ol><p><img src="https://files.mdnice.com/user/44140/59498024-1652-4caf-b542-fc9fb4634287.png"></p><h3 id="rt-smem-init"><a href="#rt-smem-init" class="headerlink" title="rt_smem_init"></a>rt_smem_init</h3><p>小内存管理算法初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_smem_t</span> <span class="hljs-title function_">rt_smem_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>    *name,</span><br><span class="hljs-params">                     <span class="hljs-type">void</span>          *begin_addr,</span><br><span class="hljs-params">                     <span class="hljs-type">rt_size_t</span>      size)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">mem</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem</span> *<span class="hljs-title">small_mem</span>;</span><br>    <span class="hljs-type">rt_ubase_t</span> start_addr, begin_align, end_align, mem_size;<br><br>    small_mem = (<span class="hljs-keyword">struct</span> rt_small_mem *)RT_ALIGN((<span class="hljs-type">rt_ubase_t</span>)begin_addr, RT_ALIGN_SIZE);<br>    start_addr = (<span class="hljs-type">rt_ubase_t</span>)small_mem + <span class="hljs-keyword">sizeof</span>(*small_mem);<br>    <span class="hljs-comment">/* 内存堆起始地址进行字节对齐 */</span><br>    begin_align = RT_ALIGN((<span class="hljs-type">rt_ubase_t</span>)start_addr, RT_ALIGN_SIZE);<br>    <span class="hljs-comment">/* 内存堆结束地址进行字节对齐 */</span><br>    end_align   = RT_ALIGN_DOWN((<span class="hljs-type">rt_ubase_t</span>)begin_addr + size, RT_ALIGN_SIZE);<br><br>    <span class="hljs-comment">/* 计算对齐之后的内存堆大小， 减去头尾 2 个数据头所占空间 */</span><br>    <span class="hljs-keyword">if</span> ((end_align &gt; (<span class="hljs-number">2</span> * SIZEOF_STRUCT_MEM)) &amp;&amp;<br>        ((end_align - <span class="hljs-number">2</span> * SIZEOF_STRUCT_MEM) &gt;= start_addr))<br>    &#123;<br>        mem_size = end_align - begin_align - <span class="hljs-number">2</span> * SIZEOF_STRUCT_MEM;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        rt_kprintf(<span class="hljs-string">&quot;mem init, error begin address 0x%x, and end address 0x%x\n&quot;</span>,<br>                   (<span class="hljs-type">rt_ubase_t</span>)begin_addr, (<span class="hljs-type">rt_ubase_t</span>)begin_addr + size);<br><br>        <span class="hljs-keyword">return</span> RT_NULL;<br>    &#125;<br><br>    rt_memset(small_mem, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*small_mem));<br>    <span class="hljs-comment">/* 初始化小内存对象 */</span><br>    rt_object_init(&amp;(small_mem-&gt;parent.parent), RT_Object_Class_Memory, name);<br>    small_mem-&gt;parent.algorithm = <span class="hljs-string">&quot;small&quot;</span>;<br>    small_mem-&gt;parent.address = begin_align;<br>    small_mem-&gt;parent.total = mem_size;<br>    small_mem-&gt;mem_size_aligned = mem_size;<br><br>    <span class="hljs-comment">/* 内存堆起始地址 */</span><br>    small_mem-&gt;heap_ptr = (<span class="hljs-type">rt_uint8_t</span> *)begin_align;<br><br>    RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="hljs-string">&quot;mem init, heap begin address 0x%x, size %d\n&quot;</span>,<br>                                (<span class="hljs-type">rt_ubase_t</span>)small_mem-&gt;heap_ptr, small_mem-&gt;mem_size_aligned));<br><br>    <span class="hljs-comment">/* 初始化第一个内存块数据头 */</span><br>    mem        = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)small_mem-&gt;heap_ptr;<br>    mem-&gt;pool_ptr = MEM_FREED();<br>    mem-&gt;next  = small_mem-&gt;mem_size_aligned + SIZEOF_STRUCT_MEM;<br>    mem-&gt;prev  = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 初始化内存堆结束数据头 */</span><br>    small_mem-&gt;heap_end        = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[mem-&gt;next];<br>    small_mem-&gt;heap_end-&gt;pool_ptr = MEM_USED();<br>    small_mem-&gt;heap_end-&gt;next  = small_mem-&gt;mem_size_aligned + SIZEOF_STRUCT_MEM;<br>    small_mem-&gt;heap_end-&gt;prev  = small_mem-&gt;mem_size_aligned + SIZEOF_STRUCT_MEM;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> RT_USING_MEMTRACE</span><br>    rt_smem_setname(small_mem-&gt;heap_end, <span class="hljs-string">&quot;INIT&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* RT_USING_MEMTRACE */</span></span><br><br>    <span class="hljs-comment">/* 空闲指针指向第一块可用内存块 */</span><br>    small_mem-&gt;lfree = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)small_mem-&gt;heap_ptr;<br><br>    <span class="hljs-keyword">return</span> &amp;small_mem-&gt;parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化之后的内存堆结构如下：</p><p><img src="https://files.mdnice.com/user/44140/d996b9c3-bb4a-4b7c-b755-f481f132b7c3.png"></p><p>初始化之后，当前的内存堆系统有以下几个属性：</p><ul><li>此时内存对系统中有两个数据头，一个表示内存堆可用内存块，另外一个表示内存堆结束数据头；随着内存的申请，数据头会依次增加</li><li>此时内存堆系统中只有一整块内存块，内存块大小为：mem_size_aliged </li><li>lfree 永远指向第一块空闲内存块，此时指向了 first mem;</li><li>heap_ptr 作为一个常量，始终指向内存堆起始地址 (begin_align)</li><li>heap_end 作为一个常量，始终指向内存堆结束数据头。</li></ul><p>假设函数入参为：begin_addr &#x3D; 0x01，size &#x3D; 0x4000；RT_ALIGN_SIZE &#x3D; 8，rt_smem_init 函数中各个变量的地址如下：</p><ul><li>begin_addr &#x3D; 0x01</li><li>small_mem &#x3D; 0x08 (8 字节向上对齐)</li><li>sizeof(struct rt_small_mem) &#x3D; 0x38</li><li>start_addr &#x3D;  (0x08 + 0x38) &#x3D; 0x40</li><li>begin_align &#x3D; 0x40 （这里 8 字节对齐刚好是 start_addr 的地址；可能会存在 begin_align &gt; start_addr 的情况，这里不做讨论）</li><li>end_align &#x3D;  0x4000（8字节向下对齐）</li><li>SIZEOF_STRUCT_MEM &#x3D; sizeof(struct rt_small_mem_item *mem) &#x3D; 0x10</li><li>mem_size_aligned &#x3D; 0x4000 - 0x40 - 2 * 0x10 &#x3D; 0x3FA0</li><li>mem-&gt;next &#x3D; 0x3FA0 + 0x10 &#x3D; 0x3FB0 (为 heap end 从 begin_align 的偏移量)</li></ul><h3 id="rt-smem-detach"><a href="#rt-smem-detach" class="headerlink" title="rt_smem_detach"></a>rt_smem_detach</h3><p>从系统中移除一个内存块对象。这个没什么过多解释，将小内存算法对象从 RT_Object_Class_Memory 链表中删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_smem_detach</span><span class="hljs-params">(<span class="hljs-type">rt_smem_t</span> m)</span><br>&#123;<br>    RT_ASSERT(m != RT_NULL);<br>    RT_ASSERT(rt_object_get_type(&amp;m-&gt;parent) == RT_Object_Class_Memory);<br>    RT_ASSERT(rt_object_is_systemobject(&amp;m-&gt;parent));<br><br>    rt_object_detach(&amp;(m-&gt;parent));<br><br>    <span class="hljs-keyword">return</span> RT_EOK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="rt-smem-alloc"><a href="#rt-smem-alloc" class="headerlink" title="rt_smem_alloc"></a>rt_smem_alloc</h3><p>从内存块中申请 size 大小的内存块；申请成功返回内存的首地址，申请失败则返回 RT_NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">rt_smem_alloc</span><span class="hljs-params">(<span class="hljs-type">rt_smem_t</span> m, <span class="hljs-type">rt_size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> ptr, ptr2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">mem</span>, *<span class="hljs-title">mem2</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem</span> *<span class="hljs-title">small_mem</span>;</span><br><br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> RT_NULL;<br><br>    <span class="hljs-comment">/* 字节对齐 */</span><br>    <span class="hljs-keyword">if</span> (size != RT_ALIGN(size, RT_ALIGN_SIZE))<br>    &#123;<br>        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="hljs-string">&quot;malloc size %d, but align to %d\n&quot;</span>,<br>                                    size, RT_ALIGN(size, RT_ALIGN_SIZE)));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="hljs-string">&quot;malloc size %d\n&quot;</span>, size));<br>    &#125;<br><br>    small_mem = (<span class="hljs-keyword">struct</span> rt_small_mem *)m;<br>    size = RT_ALIGN(size, RT_ALIGN_SIZE);<br>    <span class="hljs-keyword">if</span> (size &lt; MIN_SIZE_ALIGNED)<br>        size = MIN_SIZE_ALIGNED;<br><br>    <span class="hljs-comment">/* 申请的内存大于总内存容量 */</span><br>    <span class="hljs-keyword">if</span> (size &gt; small_mem-&gt;mem_size_aligned)<br>    &#123;<br>        <span class="hljs-keyword">return</span> RT_NULL;<br>    &#125;<br>    <span class="hljs-comment">/* 从第一个空闲内存块开始遍历，找到可用的内存块 */</span><br>    <span class="hljs-keyword">for</span> (ptr = (<span class="hljs-type">rt_uint8_t</span> *)small_mem-&gt;lfree - small_mem-&gt;heap_ptr;<br>         ptr &lt;= small_mem-&gt;mem_size_aligned - size;<br>         ptr = ((<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[ptr])-&gt;next)<br>    &#123;<br>        <span class="hljs-comment">/* 获取内存块的数据头 */</span><br>        mem = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[ptr];<br>        <span class="hljs-comment">/* 该内存块没有被使用，并且空间大小满足需求 */</span><br>        <span class="hljs-keyword">if</span> ((!MEM_ISUSED(mem)) &amp;&amp; (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM)) &gt;= size)<br>        &#123;<br>            <span class="hljs-comment">/* 内存申请完之后，该内存块还有剩余空间（&gt;= SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED） */</span><br>            <span class="hljs-keyword">if</span> (mem-&gt;next - (ptr + SIZEOF_STRUCT_MEM) &gt;=<br>                (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))<br>            &#123;<br>                <span class="hljs-comment">/* 剩余的内存空间建立新的内存块 */</span><br>                ptr2 = ptr + SIZEOF_STRUCT_MEM + size;<br>                <span class="hljs-comment">/* 内存块数据头 */</span><br>                mem2       = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[ptr2];<br>                <span class="hljs-comment">/* 标记为空闲内存块 */</span><br>                mem2-&gt;pool_ptr = MEM_FREED();<br>                mem2-&gt;next = mem-&gt;next;<br>                mem2-&gt;prev = ptr;<br>                mem-&gt;next = ptr2;<br><br>                <span class="hljs-comment">/* 判断内存堆是否结束*/</span><br>                <span class="hljs-keyword">if</span> (mem2-&gt;next != small_mem-&gt;mem_size_aligned + SIZEOF_STRUCT_MEM)<br>                &#123;<br>                    ((<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;<br>                &#125;<br>                small_mem-&gt;parent.used += (size + SIZEOF_STRUCT_MEM);<br>                <span class="hljs-keyword">if</span> (small_mem-&gt;parent.max &lt; small_mem-&gt;parent.used)<br>                    small_mem-&gt;parent.max = small_mem-&gt;parent.used;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 该内存块，内存分配完之后，剩余空间不足以建立新的内存块 */</span><br>            &#123;<br>                small_mem-&gt;parent.used += mem-&gt;next - ((<span class="hljs-type">rt_uint8_t</span> *)mem - small_mem-&gt;heap_ptr);<br>                <span class="hljs-keyword">if</span> (small_mem-&gt;parent.max &lt; small_mem-&gt;parent.used)<br>                    small_mem-&gt;parent.max = small_mem-&gt;parent.used;<br>            &#125;<br>            <span class="hljs-comment">/* 将申请到的内存块修改为已被使用 */</span> <br>            mem-&gt;pool_ptr = MEM_USED();<br>            <span class="hljs-comment">/* 需要调整空闲内存链表起始地址 */</span><br>            <span class="hljs-keyword">if</span> (mem == small_mem-&gt;lfree)<br>            &#123;<br>                <span class="hljs-comment">/* 查找 mem 之后的下一个空闲块，并更新空闲块指针 */</span><br>                <span class="hljs-keyword">while</span> (MEM_ISUSED(small_mem-&gt;lfree) &amp;&amp; small_mem-&gt;lfree != small_mem-&gt;heap_end)<br>                    small_mem-&gt;lfree = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[small_mem-&gt;lfree-&gt;next];<br>            &#125;<br>            <span class="hljs-comment">/* return the memory data except mem struct */</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">rt_uint8_t</span> *)mem + SIZEOF_STRUCT_MEM;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> RT_NULL;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设此时内存堆的结构如下图所示：</p><p><img src="https://files.mdnice.com/user/44140/a1d9d45c-0c64-4320-845c-9f84083d7dde.png"></p><p>该函数的基本流程如下：</p><ol><li>检查入参 size 参数是否合法</li><li>进行字节向上对齐操作，比如入参 size 为 13，对齐后的 size 为 16（这里还是 8 字节对齐）</li><li>因为 lfree 永远指向第一个空闲内存块，所以从 lfree 开始遍历链表</li><li>判断此时内存块的大小是否满足申请需求</li><li>判断此时内存块分配完内存之后，是否还有足够的空闲建立新的内存块</li><li>将申请的内存块设置为被使用</li><li>调整 lfree 的地址，指向新的空闲内存块</li><li>返回内存块起始地址</li></ol><h4 id="获取内存块大小"><a href="#获取内存块大小" class="headerlink" title="获取内存块大小"></a>获取内存块大小</h4><p>在结构体 rt_small_mem_item  中，并没有成员变量显示指定内存块大小，如何判断内存块大小满足申请需求？</p><ul><li>在 rt_small_mem_item 结构体中，next 的值并不是一个地址，而是一个偏移量，其基地址为 begin_align </li><li>在上面的源代码中，ptr 的值就是一个偏移量，其值为 lfree 的偏移量，假设为 x1；此时可以通过数组下标的访问方式，访问内存块中任意内存数据块的数据头，mem &#x3D; (struct rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[ptr] </li><li>在上面源代码中，第一次进行 for 循环时，mem &#x3D; lfree；mem-&gt;next 获取到了 第二块 Used Memory 数据头的偏移量。假设为 x2,</li><li>通过上面获取到的两个偏移量，就可以计算中 lfree 指向的内存块的大小：（x2 - x1 - SIZEOF_STRUCT_MEM)</li></ul><h4 id="分割内存块"><a href="#分割内存块" class="headerlink" title="分割内存块"></a>分割内存块</h4><p>如果申请的内存大小，小于空闲内存块大小，并且空闲内存块分配完之后的内存空间不小于数据头 + 12 字节（32 位系统最小内存块位 12字节，64 位为 24 字节），将剩余的内存空间建立新的内存数据头：</p><h3 id="rt-smem-realloc"><a href="#rt-smem-realloc" class="headerlink" title="rt_smem_realloc"></a>rt_smem_realloc</h3><p>调整之前已分配的内存块大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">rt_smem_realloc</span><span class="hljs-params">(<span class="hljs-type">rt_smem_t</span> m, <span class="hljs-type">void</span> *rmem, <span class="hljs-type">rt_size_t</span> newsize)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> size;<br>    <span class="hljs-type">rt_size_t</span> ptr, ptr2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">mem</span>, *<span class="hljs-title">mem2</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem</span> *<span class="hljs-title">small_mem</span>;</span><br>    <span class="hljs-type">void</span> *nmem;<br><br>    small_mem = (<span class="hljs-keyword">struct</span> rt_small_mem *)m;<br>    <span class="hljs-comment">/* 字节对齐 */</span><br>    newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);<br>    <span class="hljs-keyword">if</span> (newsize &gt; small_mem-&gt;mem_size_aligned)<br>    &#123;<br>        RT_DEBUG_LOG(RT_DEBUG_MEM, (<span class="hljs-string">&quot;realloc: out of memory\n&quot;</span>));<br><br>        <span class="hljs-keyword">return</span> RT_NULL;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newsize == <span class="hljs-number">0</span>) <span class="hljs-comment">/* 重新分配的内存块大小为0，申请该内存块 */</span><br>    &#123;<br>        rt_smem_free(rmem);<br>        <span class="hljs-keyword">return</span> RT_NULL;<br>    &#125;<br><br>    <span class="hljs-comment">/* 申请一个新的内存块 */</span><br>    <span class="hljs-keyword">if</span> (rmem == RT_NULL)<br>        <span class="hljs-keyword">return</span> rt_smem_alloc(&amp;small_mem-&gt;parent, newsize);<br><br>    mem = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)((<span class="hljs-type">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);<br><br>    <span class="hljs-comment">/* 计算内存块当前大小 */</span><br>    ptr = (<span class="hljs-type">rt_uint8_t</span> *)mem - small_mem-&gt;heap_ptr;<br>    size = mem-&gt;next - ptr - SIZEOF_STRUCT_MEM;<br>    <span class="hljs-keyword">if</span> (size == newsize)<br>    &#123;<br>        <span class="hljs-comment">/* 当前内存空间大小和要重新分配的大小相同，不进行分配，直接返回 */</span><br>        <span class="hljs-keyword">return</span> rmem;<br>    &#125;<br>    <span class="hljs-comment">/* 新的内存空间大小小于旧的内存空间大小，并且满足分离内存块的条件，将当前内存块进行分割 */</span><br>    <span class="hljs-keyword">if</span> (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE &lt; size)<br>    &#123;<br>        <span class="hljs-comment">/* 分离内存块 */</span><br>        small_mem-&gt;parent.used -= (size - newsize);<br>        <span class="hljs-comment">/* 分离出来的内存块标记为 free */</span><br>        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;<br>        mem2 = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[ptr2];<br>        mem2-&gt;pool_ptr = MEM_FREED();<br>        mem2-&gt;next = mem-&gt;next;<br>        mem2-&gt;prev = ptr;<br><br>        mem-&gt;next = ptr2;<br>        <span class="hljs-keyword">if</span> (mem2-&gt;next != small_mem-&gt;mem_size_aligned + SIZEOF_STRUCT_MEM)<br>        &#123;<br>            ((<span class="hljs-keyword">struct</span> rt_small_mem_item *)&amp;small_mem-&gt;heap_ptr[mem2-&gt;next])-&gt;prev = ptr2;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mem2 &lt; small_mem-&gt;lfree)<br>        &#123;<br>            <span class="hljs-comment">/* 修改 lfree 的指向 */</span><br>            small_mem-&gt;lfree = mem2;<br>        &#125;<br>        <span class="hljs-comment">/* 合并内存块 */</span><br>        plug_holes(small_mem, mem2);<br>        <span class="hljs-comment">/* 返回新内存块的地址 */</span><br>        <span class="hljs-keyword">return</span> rmem;<br>    &#125;<br><br>    <span class="hljs-comment">/* 重新申请 newsize 大小的内存空间 */</span><br>    nmem = rt_smem_alloc(&amp;small_mem-&gt;parent, newsize);<br>    <span class="hljs-keyword">if</span> (nmem != RT_NULL) <span class="hljs-comment">/* 检查新申请的内存 */</span><br>    &#123;<br>        <span class="hljs-comment">/* 将旧内存块的数据拷贝到新的内存块地址空间 */</span><br>        rt_memcpy(nmem, rmem, size &lt; newsize ? size : newsize);<br>        <span class="hljs-comment">/* 释放旧内存块 */</span><br>        rt_smem_free(rmem);<br>    &#125;<br>    <span class="hljs-comment">/* 返回新内存块的地址 */</span><br>    <span class="hljs-keyword">return</span> nmem;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新分配内存空间有以下几种可能性：</p><ol><li>newsize 大于内存堆的总大小，判定为非法入参，返回错误码</li><li>newsize 为 0，释放 rmem 内存空间</li><li>rmem 为 NULL，调用 malloc 函数，申请内存空间</li><li>size 等于 newsize ，不进行内存分配，直接返回 rmem</li><li>newsize + SIZEOF_STRUCT_MEM + MIN_SIZE 小于 size，说明 rmem 内存空间可以进行内存分割；最后判断是否可以进行内存块合并。其效果如下：</li><li>newsize 大于 size，直接调用 rt_smem_alloc 函数，寻找新的可用内存块；如果申请成功，将旧内存块上的内容拷贝到新的内存空间</li></ol><h3 id="rt-smem-free"><a href="#rt-smem-free" class="headerlink" title="rt_smem_free"></a>rt_smem_free</h3><p>内存释放接口，将内存归还到内存堆中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">rt_smem_free</span><span class="hljs-params">(<span class="hljs-type">void</span> *rmem)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem_item</span> *<span class="hljs-title">mem</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_small_mem</span> *<span class="hljs-title">small_mem</span>;</span><br><br>    <span class="hljs-keyword">if</span> (rmem == RT_NULL)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">/* 获取内存块数据头 */</span><br>    mem = (<span class="hljs-keyword">struct</span> rt_small_mem_item *)((<span class="hljs-type">rt_uint8_t</span> *)rmem - SIZEOF_STRUCT_MEM);<br>    small_mem = MEM_POOL(mem);<br>    <span class="hljs-comment">/* 修改内存块状态 */</span><br>    mem-&gt;pool_ptr = MEM_FREED();<br>    <span class="hljs-keyword">if</span> (mem &lt; small_mem-&gt;lfree)<br>    &#123;<br>        <span class="hljs-comment">/* 修改 lfree 的指向 */</span><br>        small_mem-&gt;lfree = mem;<br>    &#125;<br>    <span class="hljs-comment">/* 修改已使用内存块的大小 */</span><br>    small_mem-&gt;parent.used -= (mem-&gt;next - ((<span class="hljs-type">rt_uint8_t</span> *)mem - small_mem-&gt;heap_ptr));<br><br>    <span class="hljs-comment">/* 最后，进行内存块合并 */</span><br>    plug_holes(small_mem, mem);<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的基本流程如下：</p><ol><li>获取要释放的内存区域数据头</li><li>将内存块设置为未使用状态</li><li>如果内存块的地址小于 lfree，则修改 lfree 的指向</li><li>修改已被使用的内存大小</li><li>合并内存块</li></ol><p><strong>注意：释放过后的内存区域并没有清理数据，会有脏数据存在。再次申请时，可以通过 memset 清理脏数据。</strong></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在小内存管理算法中，如果频繁的进行内存的申请和释放，会产生内存碎片，造成的结果是没有可用的内存空间可以申请。</p>]]></content>
    
    
    
    <tags>
      
      <tag>rt-thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/29/STL/"/>
    <url>/2023/05/29/STL/</url>
    
    <content type="html"><![CDATA[<h1 id="STL（standard-Template-Library）"><a href="#STL（standard-Template-Library）" class="headerlink" title="STL（standard Template Library）"></a>STL（standard Template Library）</h1><h2 id="STL-的诞生"><a href="#STL-的诞生" class="headerlink" title="STL 的诞生"></a>STL 的诞生</h2><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>c++ 的面向对象和泛型编程思想，目的就是复用性的提升</p></li><li><p>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准，诞生了 STL</p></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>STL 从广义上分为：容器（container），算法 (algorithm)，迭代器 (iterator)</p></li><li><p>容器和算法之间通过迭代器进行无缝连接</p></li><li><p>STL 几乎所有的代码都采用了模板或者模板函数</p></li></ul><h2 id="STL-六大组件"><a href="#STL-六大组件" class="headerlink" title="STL 六大组件"></a>STL 六大组件</h2><ul><li><p>容器：各种数据结构，如：vector、list、deque、set、map 等，用来存放数据</p></li><li><p>算法：各种常用算法。如：sort、find、copy、for_each</p></li><li><p>迭代器：扮演了容器与算法之间的胶合剂</p></li><li><p>仿函数：行为类似函数，可作为算法的某种策略</p></li><li><p>适配器（配接器）：修饰容器或者仿函数或迭代器接口的东西</p></li><li><p>空间配置器：负责空间的配置和管理</p></li></ul><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul><li><p>关联式容器：二叉树结构</p></li><li><p>序列式容器：强调值的排序</p></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>有限的步骤，解决逻辑或者数学上的问题</p><ul><li><p>质变算法：运算过程中会更改区间内的元素的内容。如：拷贝、替换、删除等</p></li><li><p>非质变算法：运算过程中不会更改区间内的元素内容。如：查找、计数、遍历等</p></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>提供一种方法，使之能够依序访问某个容器所含的各个元素，而又无需暴露该容器的内部表示方法。</p><p>种类:</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td></td><td></td></tr><tr><td>输出迭代器</td><td></td><td></td></tr><tr><td>前向迭代器</td><td></td><td></td></tr><tr><td>双向迭代器</td><td></td><td></td></tr><tr><td>随机访问迭代器</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator i = v.<span class="hljs-built_in">begin</span>(); i != v.<span class="hljs-built_in">end</span>(); ++i) &#123;<br>        std::cout &lt;&lt; *i &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for (auto &amp;i: v) &#123;</span><br><span class="hljs-comment">         std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0<br>1<br>2<br>3<br></code></pre></td></tr></table></figure><h2 id="std"><a href="#std" class="headerlink" title="std"></a>std</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string st1 = <span class="hljs-string">&quot;hello, world&quot;</span>;<br><span class="hljs-function">std::string <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot;hello, world&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str1;<br>    str1 = <span class="hljs-string">&quot;hello, world&quot;</span>;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br><br>    string str2;<br>    str2 = str1;<br>    cout &lt;&lt; str2 &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 单个字符赋值 */</span><br>    string str3;<br>    str3 = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    cout &lt;&lt; str3 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 把字符串 s 赋值给当前字符串</span><br>    string str4;<br>    str4.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello, c++&quot;</span>);<br>    cout &lt;&lt; str4 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 把当前字符串 S 的前 n 个字符赋值给当前字符串</span><br>    string str5;<br>    str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello, c++&quot;</span>, <span class="hljs-number">5</span>);<br><br>    string str6;<br>    str6.<span class="hljs-built_in">assign</span>(str5);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, world<br>hello, world<br>a<br>hello, c++<br></code></pre></td></tr></table></figure><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string str1 = <span class="hljs-string">&quot;,world&quot;</span>;<br><br>    str += <span class="hljs-string">&quot;, world&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str += <span class="hljs-string">&#x27;,&#x27;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str += str1;<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;,world&quot;</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;,world&quot;</span>, <span class="hljs-number">8</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(str1);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(str1, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">hello ,</span> world<br><span class="hljs-built_in">hello,</span><br><span class="hljs-built_in">hello ,</span>world<br><span class="hljs-built_in">hello ,</span>world<br><span class="hljs-built_in">hello ,</span>world<br><span class="hljs-built_in">hello ,</span>world<br><span class="hljs-built_in">hello ,</span>world<br></code></pre></td></tr></table></figure><h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;liukangcc, hello, world!&quot;</span>)</span></span>;<br><br>    cout &lt;&lt;str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    cout &lt;&lt;str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    cout &lt;&lt;str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) &lt;&lt; endl;<br>    cout &lt;&lt;str.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;hello&quot;</span>, str.<span class="hljs-built_in">size</span>()) &lt;&lt; endl;<br>    cout &lt;&lt;str.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;c&#x27;</span>, str.<span class="hljs-built_in">size</span>()) &lt;&lt; endl;<br>    cout &lt;&lt;str.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, str.<span class="hljs-built_in">size</span>(), <span class="hljs-number">5</span>) &lt;&lt; endl;<br><br>    string str_son = str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-string">&quot;iopwsopq&quot;</span>);<br>    cout &lt;&lt; str_son &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-number">11</span><br><span class="hljs-number">7</span><br><span class="hljs-number">11</span><br><span class="hljs-number">11</span><br><span class="hljs-number">8</span><br><span class="hljs-number">11</span><br><span class="hljs-built_in">iopwsopq,</span> hello, world!<br></code></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;liukangcc, hello, world!&quot;</span>)</span></span>;<br>    <span class="hljs-function">string <span class="hljs-title">str1</span><span class="hljs-params">(<span class="hljs-string">&quot;liukangcc, hello, world.&quot;</span>)</span></span>;<br><br>    cout &lt;&lt;str.<span class="hljs-built_in">compare</span>(str1) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-1<br></code></pre></td></tr></table></figure><h4 id="字符存取"><a href="#字符存取" class="headerlink" title="字符存取"></a>字符存取</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br>using namespace std;<br><br>int main() &#123;<br>    string <span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;liukangcc, hello, world!&quot;</span>);<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cout &lt;&lt;<span class="hljs-built_in">str</span>[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-literal">endl</span>;<br><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        cout &lt;&lt;<span class="hljs-built_in">str</span>.at(i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-literal">endl</span>;<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">liukangcc,</span> hello, world!<br><span class="hljs-built_in">liukangcc,</span> hello, world!<br></code></pre></td></tr></table></figure><h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>** 功能描述：**</p><ul><li>对 string 字符串进行插入和删除字符操作</li></ul><p>** 函数原型：**</p><ul><li><p>string&amp; insert(int pos, const char* s); &#x2F;&#x2F; 插入字符串</p></li><li><p>string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F; 插入字符串</p></li><li><p>string&amp; insert(int pos, int n, char c); &#x2F;&#x2F; 在指定位置插入 n 个字符 c</p></li><li><p>string&amp; erase(int pos, int n &#x3D; npos); &#x2F;&#x2F; 删除从 Pos 开始的 n 个字符</p></li></ul><h4 id="string-子串"><a href="#string-子串" class="headerlink" title="string 子串"></a>string 子串</h4><p>** 功能描述：**</p><ul><li>从字符串中获取想要的子串</li></ul><p>** 函数原型：**</p><ul><li>string substr(int pos &#x3D; 0, int n &#x3D; npos) const;&#x2F;&#x2F; 返回由 pos 开始的 n 个字符组成的字符串</li></ul><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>** 功能：**</p><ul><li>vector 数据结构和 ** 数组非常相似 **，也称为 ** 单端数组 **</li></ul><p><strong>vector 与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而 vector 可以 ** 动态扩展 **</li></ul><p>** 动态扩展：**</p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><p><img src="https://vipkshttps6.wiz.cn/editor/784db3c0-1b4e-11ec-8bf2-3759ddf0e07e/00bdc86a-e379-48e6-8130-caa4c67af74b/resources/9nFThyYcSUxOVWcufNTesMx_ihe6mOAj7Q6bBr34OYs.png?token=W.0t45nsSJjIsEtzO7zjBZHWUXJy17Nh5Ix9ch_Vy61Knaa3PJBjHO250GmTkd1aA" alt="img"></p><ul><li>vector 容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><p>vector<T> v; &#x2F;&#x2F; 采用模板实现类实现，默认构造函数</p></li><li><p>vector(v.begin(), v.end()); &#x2F;&#x2F; 将 v[begin(), end()) 区间中的元素拷贝给本身。</p></li><li><p>vector(n, elem); &#x2F;&#x2F; 构造函数将 n 个 elem 拷贝给本身。</p></li><li><p>vector(const vector &amp;vec); &#x2F;&#x2F; 拷贝构造函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v1; <span class="hljs-comment">// 无参构造</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector</span>(v1);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;<br>    <span class="hljs-built_in">printVector</span>(v2);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br>    <span class="hljs-built_in">printVector</span>(v3);<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br>    <span class="hljs-built_in">printVector</span>(v4);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-built_in">test01</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">100 </span><span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p>** 功能描述：**</p><ul><li>给 vector 容器进行赋值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; it : v) &#123;<br>        cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        v1.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-built_in">printVector</span>(v1);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2 = v1;<br>    <span class="hljs-built_in">printVector</span>(v2);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v3 ;<br>    v3.<span class="hljs-built_in">assign</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">printVector</span>(v3);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; v4 ;<br>    v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">printVector</span>(v4);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 1 2 3 4 5 6 7 8 9<br>0 1 2 3 4 5 6 7 8 9<br>0 1 2 3 4 5 6 7 8 9<br>100 100 100 100 100 100 100 100 100 100<br></code></pre></td></tr></table></figure><h4 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小"></a>容量和大小</h4><p>** 功能描述：**</p><ul><li>对 vector 容器的容量和大小操作</li></ul><p>** 函数原型：**</p><ul><li><p>empty()                        判断容器是否为空</p></li><li><p>capacity()                     容器的容量</p></li><li><p>size();                            返回容器中元素的个数</p></li><li><p>resize(int num)            重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p>resize(int num, elem)  重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li><p>erase</p></li><li><p>remove</p></li></ul><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>描述：双端数组，可以对头进行插入删除操作</p><ul><li><p>deque 与 vector 区别：vector 对于头部的插入删除效率低，数据量越大，效率越低</p></li><li><p>deque 相对而言，对头部的插入删除速度会比 vector 快，vector 访问元素时的速度会比 deque 快, 这和两者内部实现有关</p></li><li><p>deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。** 当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。**</p></li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>互斥量。保护共享资源，任意时刻只允许一个线程访问共享资源。</p><ul><li><p>mutex.lock() 上锁</p></li><li><p>mutex.unlock() 解锁</p></li></ul><h3 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h3><p>mutex 会造成死锁。lock_guard() 只有构造函数和析构函数，当调用构造函数时，会自动传入的对象的 lock() 函数，而当调用析构函数时，自动调用 unlock() 函数。std::lock_guard 是非常巧妙的一种设计思路，利用类对象的生命周期，构造时使互斥量加锁，析构时使互斥量解锁，从而实现其 ** 作用域内 ** 对互斥量的管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br>std::mutex mtx;<br><br><span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_lock</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// create a lock_guard class</span><br>    std::thread::id id = std::this_thread::<span class="hljs-built_in">get_id</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;cout ----- id :&quot;</span> &lt;&lt; id  &lt;&lt; std::endl;<br><br>    number++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (number&gt;= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">test_lock</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;thread number:&quot;</span> &lt;&lt; number &lt;&lt; std::endl;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(test_thread)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(test_thread)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;number is:&quot;</span> &lt;&lt; number &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">2</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">1</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">3</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">2</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">3</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">3</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">2</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">4</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">2</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">5</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">3</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">6</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">2</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">7</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">3</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">8</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">2</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">9</span><br><span class="hljs-attribute">cout</span> ----- id : <span class="hljs-number">3</span><br><span class="hljs-attribute">thread</span> number: <span class="hljs-number">10</span><br><span class="hljs-attribute">number</span> is: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是 STL 的一个关联容器，以键值对存储的数据，其类型可以自己定义，每个关键字在 map 中只能出现一次，关键字不能修改，值可以修改；map 同 set、multiset、multimap（与 map 的差别仅在于 multimap 允许一个键对应多个值）内部数据结构都是红黑树，而 java 中的 hashmap 是以 hash table 实现的。所以 map 内部有序（自动排序，单词时按照字母序排序），查找时间复杂度为 O(logn)。</p><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><ul><li><p>头文件： <code>#include &lt;map&gt;</code></p></li><li><p>定义：</p><ul><li>&lt;int, sting&gt; my_map;</li><li>typedef map&lt;int, string&gt; My_Map;</li><li>My_Map my_map;</li></ul></li></ul><h5 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h5><ul><li><p>my_map.insert()</p></li><li><p>my_map.emplace()</p></li></ul><h5 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h5><ul><li>my_map.clear()</li></ul><h5 id="删除一个元素"><a href="#删除一个元素" class="headerlink" title="删除一个元素"></a>删除一个元素</h5><ul><li>my_map.erase()</li></ul><h5 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h5><ul><li>my_map.size()</li></ul><h5 id="获取头部的迭代器"><a href="#获取头部的迭代器" class="headerlink" title="获取头部的迭代器"></a>获取头部的迭代器</h5><ul><li>my_map.begin()</li></ul><h5 id="获取末尾的迭代器"><a href="#获取末尾的迭代器" class="headerlink" title="获取末尾的迭代器"></a>获取末尾的迭代器</h5><ul><li>my_map.end()</li></ul><h5 id="判断-map-是否为空"><a href="#判断-map-是否为空" class="headerlink" title="判断 map 是否为空"></a>判断 map 是否为空</h5><ul><li>my_map.empty()</li></ul><h5 id="交换两个-map"><a href="#交换两个-map" class="headerlink" title="交换两个 map"></a>交换两个 map</h5><p>两个 map 中所有元素都交换</p><ul><li>my_map.swap()</li></ul><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul><li><p>第一种：用 insert 函数插入 pair 数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>,string&gt; my_map;<br>my_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,string&gt;(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;first&quot;</span>));<br>my_map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,string&gt;(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;second&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>第二种：用 insert 函数插入 value_type 数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>,string&gt; my_map;<br>my_map.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>,string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;first&quot;</span>));<br>my_map.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>,string&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;second&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>第三种：用数组的方式直接赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++">  map&lt;<span class="hljs-type">int</span>,string&gt; my_map;<br>  my_map[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;first&quot;</span>;<br>  my_map[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;second&quot;</span>;<br><br>##### 遍历<br><br>```c++<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mp;<br><br>    mp[<span class="hljs-string">&quot;Li&quot;</span>] = <span class="hljs-number">20</span>;<br>    mp[<span class="hljs-string">&quot;Wang&quot;</span>] = <span class="hljs-number">18</span>;<br>    mp[<span class="hljs-string">&quot;Zhao&quot;</span>] = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 方式一、迭代器</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;first: itor&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>(); it++) &#123;<br>        cout &lt;&lt;it-&gt;first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 方式二、range for C++ 11 版本及以上</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;second: range for&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : mp) &#123;<br>        cout &lt;&lt; it.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; it.second &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 方法三、 C++ 17 版本及以上</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;third&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [key, val] : mp) &#123;<br>        cout &lt;&lt; key  &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">first: itor<br>Zhao 30<br>Wang 18<br>Li 20<br>second: range for<br>Zhao 30<br>Wang 18<br>Li 20<br>third<br>Zhao 30<br>Wang 18<br>Li 20<br></code></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>std::bind 的 [头文件](<a href="https://so.csdn.net/so/search?q">https://so.csdn.net/so/search?q</a> &#x3D; 头文件 &amp; spm&#x3D;1001.2101.3001.7020) 是 ，它是一个函数适配器，接受一个可调用对象（callable object），生成一个新的可调用对象来 “适应” 原对象的参数列表。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>std::bind 函数有两种函数原型，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/*unspecified*/</span> <span class="hljs-built_in">bind</span>(F&amp;&amp; f, Args&amp;&amp;... args);<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-comment">/*unspecified*/</span> <span class="hljs-built_in">bind</span>(F&amp;&amp; f, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><p>std::bind 返 回一个基于 f 的函数对象，其参数被绑定到 args 上 。</p><p>f 的参数要么被绑定到值，要么被绑定到 placeholders（占位符，如_1, _2, …, _n）。</p><p>std::bind 将可调用对象与其参数一起进行绑定，绑定后的结果可以使用 std::function 保存。std::bind 主要有以下两个作用：</p><p>将可调用对象和其参数绑定成一个防函数；</p><p>只绑定部分参数，减少可调用对象传入的参数。</p><h4 id="绑定普通函数"><a href="#绑定普通函数" class="headerlink" title="绑定普通函数"></a>绑定普通函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">callableFunc</span> <span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x/y;&#125;<br><span class="hljs-keyword">auto</span> NewCallable = std::<span class="hljs-built_in">bind</span> (callableFunc, std::placeholders::_1,<span class="hljs-number">2</span>);<br><br>std::cout &lt;&lt;<span class="hljs-built_in">NewCallable</span> (<span class="hljs-number">10</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li><p>bind 的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此 std::bind(callableFunc,_1,2) 等价于 std::bind (&amp;callableFunc,_1,2)；</p></li><li><p>_1 表示占位符，位于 <functional> 中，std::placeholders::_1；</p></li><li><p>第一个参数被占位符占用，表示这个参数以调用时传入的参数为准，在这里调用 NewCallable 时，给它传入了 10，其实就想到于调用 callableFunc(10,2);</p></li></ul><h4 id="绑定一个成员函数"><a href="#绑定一个成员函数" class="headerlink" title="绑定一个成员函数"></a>绑定一个成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span> </span>&#123;<br>        std::cout &lt;&lt; a1 + a2 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m_data = <span class="hljs-number">30</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   Base base;<br>   <span class="hljs-keyword">auto</span> newiFunc = std::<span class="hljs-built_in">bind</span>(&amp;Base::display_sum, &amp;base, <span class="hljs-number">100</span>, std::placeholders::_1);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>bind 绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</p></li><li><p>必须显式地指定 &amp; Base::diplay_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在 Base::display_sum 前添加 &amp;；</p></li><li><p>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;base；</p></li></ul><h4 id="绑定一个引用参数"><a href="#绑定一个引用参数" class="headerlink" title="绑定一个引用参数"></a>绑定一个引用参数</h4><p>默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">ostream &amp; <span class="hljs-title">printInfo</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-type">const</span> string&amp; s, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    os &lt;&lt; s &lt;&lt; c;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    vector&lt;string&gt; words&#123;<span class="hljs-string">&quot;welcome&quot;</span>, <span class="hljs-string">&quot;to&quot;</span>, <span class="hljs-string">&quot;C++11&quot;</span>&#125;;<br>    ostringstream os;<br><br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27; &#x27;</span>;<br><br>    for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), [&amp;os, c](<span class="hljs-type">const</span> string &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );<br><br>    cout &lt;&lt;os.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br><br>    ostringstream os1;<br><br>    <span class="hljs-comment">// ostream 不能拷贝，若希望传递给 bind 一个对象，</span><br>    <span class="hljs-comment">// 而不拷贝它，就必须使用标准库提供的 ref 函数</span><br>    for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<span class="hljs-built_in">bind</span>(printInfo, <span class="hljs-built_in">ref</span>(os1), _1, c));<br>    cout &lt;&lt;os1.<span class="hljs-built_in">str</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">welcome</span> to C++<span class="hljs-number">11</span><br><span class="hljs-attribute">welcome</span> to C++<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类和对象</title>
    <link href="/2023/04/25/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/04/25/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>在面向对象程序设计中，程序模块是由类构成的。类是对逻辑上相关的函数与数据的封装，它是对问题的抽象描述。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>这里以时钟为例，时钟类的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span>&#123;<br><br><span class="hljs-keyword">public</span>：<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setrime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH; <span class="hljs-type">int</span> newM; <span class="hljs-type">int</span> news)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showrime</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>：<br>  <span class="hljs-type">int</span> hour, minute, second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里，封装了时钟的数据和行为，分别称为 Clock 类的数据成员和函数成员。定义类的语法形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> 类名称<br>&#123;<br><br>   <span class="hljs-keyword">public</span>：<br>        外部接口<br><br>   <span class="hljs-keyword">protected</span>：<br>       保护型成员<br><br>   <span class="hljs-keyword">private</span>：<br>       私有成员<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="类成员的访问控制"><a href="#类成员的访问控制" class="headerlink" title="类成员的访问控制"></a>类成员的访问控制</h3><p>访问控制属性可以有以下三种：公有类型（public）、私有类型（private）和保护类型（protected）</p><ol><li><p><strong>public</strong>： 成员定义了类的外部接口。公有成员用 public 关键字声明，在类外只能访问类的公有成员。对于时钟类，从外部只能调用 setTime()和 showTime()这两个公有类型的函数成员来改变或者查看时间。</p></li><li><p><strong>private</strong>：声明的就是类的 <strong>私有成员</strong>，如果私有成员紧接着类名称，则关键字 private 可以省略。<strong>私有成员只能被本类的成员函数访问</strong>，来自类外部的任何访问都是非法的。这样，私有成员就完全隐蔽在类中，保护了数据的安全性。时钟类中的 hour，minute，second 都是私有成员。</p></li><li><p><strong>protected</strong>：<strong>保护类型成员</strong> 的性质可以被其子类获得，但是不能通过类外访问得到。</p></li></ol><h3 id="成员函数的实现"><a href="#成员函数的实现" class="headerlink" title="成员函数的实现"></a>成员函数的实现</h3><p>函数的原型声明要写在类体中，原型说明了函数的参数表和返回值类型，<strong>而函数的具体实现是写在类定义之外的</strong>。与普通函数不同的是，实现成员函数时要指明类的名称，具体形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 类名：：函数成员名（参数表）&#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clock::setTime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH,<span class="hljs-type">int</span> newM,<span class="hljs-type">int</span> newS)</span> </span>&#123;<br>   hour=newH;<br>   minute=newM;<br>   second=newS;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Clock::showTime</span><span class="hljs-params">()</span> </span>&#123;<br>   cout&lt;&lt;hour&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内联成员函数"><a href="#内联成员函数" class="headerlink" title="内联成员函数"></a>内联成员函数</h4><p>函数的调用过程要消耗一些内存资源和运行时间来传递参数和返回值，要记录调用时的状态，以便保证调用完成后能够正确地返回并继续执行。如果有的函数成员需要被频繁调用，而且代码比较简单，这个函数也可以定义为内联函数（inline function）。和普通内联函数相同，内联成员函数的函数体也会在编译时被插入到每一个调用它的地方。这样做可以减少调用的开销，提高执行效率，但是却增加了编译后的代码长度。所以要在权衡利弊的基础上慎重选择，只有对相对简单的成员函数才可以声明为内联函数。</p><p>内联函数的声明有两种方式：<strong>隐式声明</strong> 和 <strong>显式声明</strong> 。</p><p>将函数体直接放在类体中，这种方法称之为隐式声明。比如，将时钟类的 showTime()函数声明为内联函数，可以写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTime</span><span class="hljs-params">(<span class="hljs-type">int</span> newH,<span class="hljs-type">int</span> newM,<span class="hljs-type">int</span> newS)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showTime</span><span class="hljs-params">()</span></span>&#123;<br>            cout&lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt;endl;<br>      &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> hour,minute,second;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了保证类定义的简洁，可以采用关键字 inline 显式声明的方式。即在函数体实现时，在函数返回值类型前加上 inline，类定义时不加入 showTime 的函数体。请看下面的表达方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Clock::showTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt; &lt;hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>在定义对象时，可以同时对其数据成员赋初值，在定义对象时进行的数据成员设置，称为对象的初始化，在特定的对象使用结束时，需要进行一些清理工作，这里的初始化和清理工作分别由两个成员函数来完成，分别为 <strong>构造函数</strong> 和 <strong>析构函数</strong>。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数在对象被创建的时候将被自动调用。如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的参数列表和函数体皆为空。如果类中声明了构造函数（无论是否有参数），编译器便不会再为之生成隐含的构造函数。</p><p>现将 Clock 类修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Clock</span>(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS);    <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetTime</span><span class="hljs-params">(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowTime</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> Hour,Minute,Second;<br>&#125;;<br><br><span class="hljs-comment">// 构造函数的实现：</span><br>Clock::<span class="hljs-built_in">Clock</span>(<span class="hljs-type">int</span> NewH,<span class="hljs-type">int</span> NewM,<span class="hljs-type">int</span> NewS)<br>&#123;<br>    Hour=NewH;<br>    Minute=NewM;<br>    Second=NewS;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们来看一看建立对象时构造函数的作用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Clock <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span></span>;<br>    c.<span class="hljs-built_in">ShowTime</span>();<br>    c.<span class="hljs-built_in">SetTime</span>(<span class="hljs-number">8</span>,<span class="hljs-number">30</span>,<span class="hljs-number">30</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在建立对象 c 时，会隐含调用构造函数，将实参用作初始值。由于 Clock 类中定义了构造函数，所以编译系统就不会在为其生成默认构造函数了。而这里自定义的构造函数带有形参，所以建立对象就必须给出初始值，用来调用构造函数时的实参。</p><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用。其作用是使用一个已经存在的对象（由拷贝构造函数的参数指定），去初始化的一个新对象。</p><p>如果没有定义一个类的拷贝构造函数，系统会在必要时自动生成一个默认的拷贝构造函数（因为有一些操作是默认会调用拷贝构造函数），这个默认的拷贝构造函数的功能是，把初始化对象的每个数据成员的值都复制到新建立的对象中。</p><p>拷贝构造函数的例子：通过水平和垂直两个方向的坐标值 X 和 Y 来确定屏幕上的一个点。点（Point）类定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-keyword">public</span>：<br>        <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xx=<span class="hljs-number">0</span>,yy=<span class="hljs-number">0</span>)&#123;X=xx;Y=yy;&#125;<br>        <span class="hljs-built_in">Point</span>(Point&amp;p);<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetX</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> X;&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetY</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> Y;&#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> X,Y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类中声明了内联构造函数函数和拷贝构造函数。拷贝构造函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point::<span class="hljs-built_in">Point</span>(Point &amp;p)<br>&#123;<br>    X = p.X;<br>    Y = p.Y;<br>    cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通拷贝构造函数是在对象创建时被调用，而拷贝构造函数在以下三种情况下都会被调用：</p><p>1、当用类的一个对象去初始化该类的另一个对象时。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> main（）&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>，<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;    <span class="hljs-comment">// 用对象 a 初始化对象 b，复制构造函数被调用</span><br>    Point c = a;   <span class="hljs-comment">// 用对象 a 初始化对象 c，复制构造函数被调用</span><br>    cout &lt;&lt; b.<span class="hljs-built_in">GetX</span>() &lt;&lt; end1;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p>以上对 b 和 c 的初始化都能够调用复制构造函数，两种写法只是形式上有所不同，执行的操作完全相同。</p><p>2、如果函数的形参是类的对象，调用函数时，进行形参和实参结合时。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Point p)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;p.<span class="hljs-built_in">GetX</span>()&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Point a（<span class="hljs-number">1</span>,<span class="hljs-number">2</span>）；<br>    <span class="hljs-built_in">f</span>(a);   <span class="hljs-comment">// 函数的形参为类的对象，当调用函数时，进行形参和实参结合时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有把对象用值传递时，才会调用复制构造函数，如果传递引用，则不会调用复制构造函数。由于这一原因，传递比较大的对象时，传递引用会比传值的效率高很多。</p><p>3、如果函数的返回值是类的对象，函数执行完成返回调用者时。 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Point <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> a;  <span class="hljs-comment">// 函数返回值是类的对象，返回函数值时，调用拷贝构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Point b;<br>    b = <span class="hljs-built_in">g</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么在这种情况下，返回函数值时，会调用复制构造函数呢？</p><p>a 其实是一个局部变量，在 g()执行完后，就会被释放。执行语句 <strong>return a;</strong> 时，实际上是调用复制构造函数将 a 的值复制到临时对象中。</p><h3 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h3><ol><li>只有构造函数才可以使用初始化列表，其他函数使用会报错：only constructors take member initializers</li></ol><p>构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。</p><p>构造函数的初始化列表使得代码更加简洁，请看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *m_name;<br>    <span class="hljs-type">int</span> m_age;<br>    <span class="hljs-type">float</span> m_score;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 采用初始化列表</span><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score)&#123;<br> <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::show</span><span class="hljs-params">()</span></span>&#123;<br>   cout &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot;的年龄是&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="hljs-string">&quot;，成绩是&quot;</span>&lt;&lt; m_score &lt;&lt; <span class="hljs-built_in">show</span>();<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">小明的年龄是 15，成绩是 92.5<br>李华的年龄是 16，成绩是 96<br></code></pre></td></tr></table></figure><p>如本例所示，定义构造函数时并没有在函数体中对成员变量一一赋值，其函数体为空（当然也可以有其他语句），而是在函数首部与函数体之间添加了一个冒号:，后面紧跟 m_name(name), m_age(age), m_score(score) 语句，这个语句的意思相当于函数体内部的 <code>m_name = name; m_age = age; m_score = score;</code> 语句，也是赋值的意思。</p><p>使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。</p><p>初始化列表可以用于全部成员变量，也可以只用于部分成员变量。下面的示例只对 m_name 使用初始化列表，其他成员变量还是一一赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name)&#123;<br>    m_age = age;<br>    m_score = score;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。请看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CCar</span> &#123; <br>    cout&lt;&lt;m_a&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;m_b&lt; “封闭类” <br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> price;<br>        CTyre tyre;<br>        CEngine engine;<br><br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-built_in">CCar</span>(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> tr, <span class="hljs-type">int</span> tw); <br>&#125;; <br><br>CCar::<span class="hljs-built_in">CCar</span>(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> tr, <span class="hljs-type">int</span> w): <span class="hljs-built_in">price</span>(p), <span class="hljs-built_in">tyre</span>(tr, w) &#123;<br><br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br><br>    <span class="hljs-function">CCar <span class="hljs-title">car</span><span class="hljs-params">(<span class="hljs-number">20000</span>,<span class="hljs-number">17</span>,<span class="hljs-number">225</span>)</span></span>; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>如果 CCar 类不定义构造函数，则 CCar car；会编译错误</p><ol><li><p>编译器不知道 car.tyre 如何初始化</p></li><li><p>car.engine 的初始化没有问题: 用默认构造函数</p></li></ol><p>所有要明确告诉 “对象中的成员对象”如何初始化？</p><p>定义封闭类的构造函数时, 添加初始化列表:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">类名:: 构造函数(参数表): 成员变量 <span class="hljs-number">1</span>(参数表), 成员变量 <span class="hljs-number">2</span>(参数表), …<br>&#123;<br>    …<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数与构造函数的作用几乎正好相反，它用来完成对象被删除前的一些清理工作，例如释放分配的内存、关闭打开的文件等。析构函数是在对象的生存期即将结束的时刻被自动调用的。</p><p>析构函数没有参数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~ 符号。</p><h3 id="前向引用声明"><a href="#前向引用声明" class="headerlink" title="前向引用声明"></a>前向引用声明</h3><p>我们知道 C++ 的类应当是先定义，然后使用。但在处理相对复杂的问题、考虑类的组合时，很可能遇到俩个类相互引用的情况，这种情况称为循环依赖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B b)</span></span>;<span class="hljs-comment">// 以 B 类对象 b 为形参的成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(A a)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里类 A 的公有成员函数 f 的形参是类 B 的对象，同时类 B 的公有成员函数 g 也以类 A 的对象为形参。由于在使用一个类之前，必须首先定义该类，因此无论将哪一个类的定义放在前面，都会引起编译错误。结局这个问题的方法，就是使用前向引用声明。前向引用声明，是在引用未定义的类之前，将该类的名字告诉编译器，试编译器知道那是一个类名。这样，当程序中使用这个类名时，编译器就不会认为是错误，而类的完整定义可以在程序的其他地方。在上述程序加上下面的前向引用声明，问题就解决了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向引用声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><span class="hljs-comment">//A 类的定义</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">// 外部接口</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(B b)</span></span>;<span class="hljs-comment">// 以 B 类对象 b 为形参的成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><span class="hljs-comment">//B 类的定义</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<span class="hljs-comment">// 外部接口</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(A a)</span></span>;<span class="hljs-comment">// 以 A 类对象 a 为形参的成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>静态成员是解决同一个类的不同对象之间数据和函数共享问题的。</p><h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><ol><li><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，该 static 成员也只会有一个，某个对象修改了这个 static 成员，其他对象也会受到影响；</p></li><li><p>一般的用法 <strong>类名 :: 标识符</strong></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span> *m_name;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-type">float</span> m_score;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_total; <span class="hljs-comment">// 声明静态成员，此时并未分配内存空间给 m_total</span><br>&#125;;<br><br><span class="hljs-type">int</span> Student::m_total = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义并初始化静态成员 m_total，此时分配内存空间</span><br><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score) : <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score) &#123;<br>    m_total++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] name: %s, age: %d, score: %g\n&quot;</span>, m_total, m_name, m_age, m_score);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>)</span></span>;<br>    s1.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>)</span></span>;<br>    s2.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">((<span class="hljs-type">char</span> *)<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">33</span>)</span></span>;<br>    s3.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[1] name: A, age: 1, score: 11<br>[2] name: B, age: 2, score: 22<br>[3] name: C, age: 3, score: 33<br></code></pre></td></tr></table></figure><h4 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h4><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score);<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_cnt</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">float</span> <span class="hljs-title">get_sum</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_cnt;<br>        <span class="hljs-type">static</span> <span class="hljs-type">float</span> m_sum;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* m_name;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-type">float</span> m_score;<br>&#125;;<br><br><span class="hljs-type">int</span> Student::m_cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">float</span> Student::m_sum = <span class="hljs-number">0.0f</span>;<br><br>Student::<span class="hljs-built_in">Student</span>(<span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> age, <span class="hljs-type">float</span> score): <span class="hljs-built_in">m_name</span>(name), <span class="hljs-built_in">m_age</span>(age), <span class="hljs-built_in">m_score</span>(score) &#123;<br><br>   m_cnt++;<br><br>   m_sum += score;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Student::print</span><span class="hljs-params">()</span> </span>&#123;<br><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s, age: %d, score: %g\n&quot;</span>, m_name, m_age, m_score);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::get_cnt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// return m_age; 静态函数掉用普通成员，编译错误。</span><br>    <span class="hljs-comment">// error: invalid use of member &#x27;Student::m_age&#x27; in static member function</span><br>    <span class="hljs-keyword">return</span> m_cnt; <span class="hljs-comment">/* 可以访问静态成员 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Student::get_sum</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> m_sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">s1</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>)</span></span>;<br>    s1.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-function">Student <span class="hljs-title">s2</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">22</span>)</span></span>;<br>    s2.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-function">Student <span class="hljs-title">s3</span><span class="hljs-params">((<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">33</span>)</span></span>;<br>    s3.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;student_total: %d, score_total: %g\n&quot;</span>, Student::<span class="hljs-built_in">get_cnt</span>(), Student::<span class="hljs-built_in">get_sum</span>());<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: A, age: 1, score: 11<br>name: B, age: 2, score: 22<br>name: C, age: 3, score: 33<br>student_total: 3, score_total: 66<br></code></pre></td></tr></table></figure><h3 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h3><p>默认情况下，c++ 编译器至少给一个类添加 3 个函数</p><ol><li><p>默认构造函数（无参，函数体为空）</p></li><li><p>默认析构函数（无参，函数体为空）</p></li><li><p>默认拷贝构造函数，对属性进行拷贝</p></li></ol><p>构造函数的调用规则如下：</p><ol><li><p>如果用户定义了有参构造函数，c++ 不在提供默认无参构造函数，但是会提供默认拷贝构造</p></li><li><p>如果用户定义了拷贝构造函数，c++ 不在提供其他构造函数</p></li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作<br>深拷贝：在堆区重新申请空间，进行拷贝操作；</p><h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><h2 id="对象模型和-this-指针"><a href="#对象模型和-this-指针" class="headerlink" title="对象模型和 this 指针"></a>对象模型和 this 指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><p>c++ 编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置。每个空对象也应该有一个独一无二的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure><h4 id="非静态成员变量"><a href="#非静态成员变量" class="headerlink" title="非静态成员变量"></a>非静态成员变量</h4><p>属于类对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 4<br></code></pre></td></tr></table></figure><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><p>不属于类对象上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-type">int</span> Person::a = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure><h4 id="非静态成员函数"><a href="#非静态成员函数" class="headerlink" title="非静态成员函数"></a>非静态成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Person p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">size of p = 1<br></code></pre></td></tr></table></figure><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::a</span><span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>  Person p;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;size of p =&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出：<br><br>```shell<br>size of p = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h3><ol><li><p>指向被调用的成员函数所属的对象</p></li><li><p>隐含每一个非静态成员函数内的一种指针</p></li><li><p>不需要定义，直接使用即可</p></li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li><p>当形参和成员变量同名时，可用 this 指针来区分</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用 return *this</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<span class="hljs-keyword">this</span>-&gt;age = age;&#125; <span class="hljs-comment">/* 用途 1 */</span><br><br>        <span class="hljs-function">Person&amp; <span class="hljs-title">PersonAgeAdd</span><span class="hljs-params">(Person &amp;p)</span>   <span class="hljs-comment">/* 用途 2 */</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">this</span>-&gt;age += p.age;<br>            <span class="hljs-comment">/* 返回对象本身 */</span><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">/* 链式编程思想 */</span><br>    p2.<span class="hljs-built_in">PersonAgeAdd</span>(p1).<span class="hljs-built_in">PersonAgeAdd</span>(p1).<span class="hljs-built_in">PersonAgeAdd</span>(p1);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p2.age:&quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>c++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针。如果用到 this 指针，需要加以判断保证代码的健壮性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">使用空指针访问类的成员函数和成员变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPersonAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//    if (this == nullptr) &#123;</span><br>        <span class="hljs-comment">//      return;</span><br>        <span class="hljs-comment">//    &#125;</span><br>             std::cout &lt;&lt; <span class="hljs-string">&quot;age=&quot;</span> &lt;&lt; age &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Person *p = <span class="hljs-literal">NULL</span>;<br>    p-&gt;<span class="hljs-built_in">showClassName</span>(); <span class="hljs-comment">/* 可以访问成员函数 */</span><br>    p-&gt;<span class="hljs-built_in">showPersonAge</span>(); <span class="hljs-comment">/* 不能访问成员变量 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, world!<br><br>age=<br><br>Process finished with exit code -1073741819 (0xC0000005)<br></code></pre></td></tr></table></figure><p> 当上面的测试用例在访问类的属性时，代码异常退出。可以取消注释代码，增强程序的健壮性。</p><h2 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h2><h3 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h3><ol><li><p>成员函数后加 const 后我们称这个函数为常函数</p></li><li><p>常函数内不可以修改成员属性</p></li><li><p>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改</p></li></ol><h3 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h3><ol><li><p>声明对象前加 const 称对象为常对象</p></li><li><p>常对象只能调用常函数</p></li></ol><p>示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>             std::cout &lt;&lt; <span class="hljs-string">&quot;hello, world!&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-comment">/* this 指针的本质是指针常量， 指针的指向不可以修改</span><br><span class="hljs-comment">        \* const Person* const this</span><br><span class="hljs-comment">        \* */</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-comment">/* 常函数 */</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-comment">//    this-&gt;m_age = 19; /* 不可以修改 */</span><br>             <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">20</span>;   <span class="hljs-comment">/* 使用 mutable 修饰，可以修改 */</span><br>        &#125;<br>        <span class="hljs-type">int</span> m_age;<br>        <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">const</span> Person p; <span class="hljs-comment">/* 常对象 */</span><br>    <span class="hljs-comment">//p.m_age = 10; /* 不可以修改 */</span><br>    p.m_B = <span class="hljs-number">10</span>; <span class="hljs-comment">/* 可以修改 */</span><br>    <span class="hljs-comment">/* 常对象只能调用常函数 */</span><br>    p.<span class="hljs-built_in">hello</span>(); <span class="hljs-comment">/* 不可以访问 */</span><br>    p.<span class="hljs-built_in">showAge</span>(); <span class="hljs-comment">/* 可以访问 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里面，有些私有属性也想让类外特殊的一些函数或者类进行访问</p><p>友元的关键词为 friend</p><p>友元的三种实现</p><ol><li><p>全局函数做友元</p></li><li><p>类做友元</p></li><li><p>成员函数做友元</p></li></ol><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><p>一个函数可以访问一个类中的私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><br>    <span class="hljs-comment">/* goodGay 全局函数是 Building 的友元函数, 可以访问 Building 中私有成员 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building *building)</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>() &#123;<br>             m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>             m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>        &#125;<br><br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br><span class="hljs-comment">/* 友元函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building *building)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;now:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Building building;<br>    <span class="hljs-built_in">goodGay</span>(&amp;building);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">now: woshi<br></code></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p>一个类可以访问另外一个类中的私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> ;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br><br>  Building *building;<br><br>  <span class="hljs-built_in">GoodGay</span>();<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span>; <span class="hljs-comment">/* 友元类 */</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>();<br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>    m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>&#125;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay goodGay;<br>    goodGay.<span class="hljs-built_in">visit</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">woshi<br></code></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> ;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit1</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问 Building 中的属性</span><br>        Building *building;<br>        <span class="hljs-built_in">GoodGay</span>();<br>        ~<span class="hljs-built_in">GoodGay</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit1</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Building</span>();<br>        string m_stittingRoom;<br><br>    <span class="hljs-keyword">private</span>:<br>        string m_BedRoom;<br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>() &#123;<br>    m_stittingRoom = <span class="hljs-string">&quot;keting&quot;</span>;<br>    m_BedRoom = <span class="hljs-string">&quot;woshi&quot;</span>;<br>&#125;<br><br>GoodGay::<span class="hljs-built_in">GoodGay</span>() &#123;<br>    building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br>GoodGay::~<span class="hljs-built_in">GoodGay</span>() &#123;<br>    <span class="hljs-keyword">if</span> (building) &#123;<br>         <span class="hljs-keyword">delete</span> building;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 不可访问私有成员 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl; <span class="hljs-comment">/* 编译报错 */</span><br>&#125;<br><br><span class="hljs-comment">/* 成员函数作为友元，可以访问类中的私有成员 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GoodGay::visit1</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;visit:&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    GoodGay goodGay;<br>    goodGay.<span class="hljs-built_in">visit</span>();<br>    goodGay.<span class="hljs-built_in">visit1</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为[派生类](<a href="https://baike.baidu.com/item">https://baike.baidu.com/item</a> &#x2F; 派生类 &#x2F; 9589520?fromModule&#x3D;lemma_inlink)，又称为子类。</p><p>class A: public&#x2F;private&#x2F;protected B;</p><ol><li><p>A 称为子类或者派生类</p></li><li><p>B 称为父类或者基类</p></li></ol><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法：class 子类： 继承方式 父类 </p><ol><li><p>公共继承</p></li><li><p>保护继承</p></li><li><p>私有继承</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodGay</span> &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a;<br>    <br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>: <span class="hljs-keyword">public</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//    c = 30; 父类中的私有成员，公有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">protected</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//     c = 30; 父类中的私有成员，公有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">private</span> GoodGay &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    a = <span class="hljs-number">10</span>;<br>        ​    b = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//    c = 30; 父类中的私有成员，私有继承无法访问</span><br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    A A1;<br><br>    A1.a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 父类中的公有成员，公有继承后变为公有成员，类外可以访问</span><br>    <span class="hljs-comment">//  A1.b = 20; 父类中的保护成员，公有继承后依然为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  A1.c = 30; 父类中的私有成员，公有继承无法访问</span><br><br>    B B1;<br>    <span class="hljs-comment">//  B1.a = 20; 父类中的公有成员，保护继承后变为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  B1.b = 20; 父类中的保护成员，保护继承后依然为保护成员，类外无法访问</span><br>    <span class="hljs-comment">//  B1.c = 20; 父类中的私有成员，公有继承无法访问</span><br><br>    C C1;<br>    <span class="hljs-comment">//  C1.a = 10; 父类中的公有成员，私有继承后变为私有成员，类外无法访问</span><br>    <span class="hljs-comment">//  C1.b = 10; 父类中的保护成员，私有继承后变为私有成员，类外无法访问</span><br>    <span class="hljs-comment">//  C2.c = 10; 父类中的私有成员，私有继承后变为私有成员，类外无法访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-built_in">test01</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><ol><li><p>在父类中所有非静态成员属性都有会被子类继承下去</p></li><li><p>父类中私有的成员属性是被编译器给隐藏了，因此访问不到，但是还是会被子类继承下去</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> a;<br><br>    <span class="hljs-keyword">protected</span>:<br>        <span class="hljs-type">int</span> b;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> c;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> d;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Father) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">12<br><br>16<br></code></pre></td></tr></table></figure><h3 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h3><ol><li><p>父类的构造函数</p></li><li><p>子类的构造函数</p></li><li><p>子类的析构函数</p></li><li><p>父类的析构函数</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Father</span>();<br>        ~<span class="hljs-built_in">Father</span>();<br>&#125;;<br><br>Father::<span class="hljs-built_in">Father</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Father::Father&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Father::~<span class="hljs-built_in">Father</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Father::~Father&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Son</span>();<br>        ~<span class="hljs-built_in">Son</span>();<br>&#125;;<br><br>Son::<span class="hljs-built_in">Son</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son::Son&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Son::~<span class="hljs-built_in">Son</span>() &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Son::~Son&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son s1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Father::Father<br><br>Son::Son<br><br>Son::~Son<br><br>Father::~Father<br></code></pre></td></tr></table></figure><h3 id="继承中同名成员处理方式"><a href="#继承中同名成员处理方式" class="headerlink" title="继承中同名成员处理方式"></a>继承中同名成员处理方式</h3><ol><li><p>访问子类同名成员时，直接访问即可</p></li><li><p>访问父类同名成员时，需要加作用域</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;father::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">100</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m = <span class="hljs-number">200</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Son s1;<br><br>    s1.<span class="hljs-built_in">printf</span>();<br>    s1.Father::<span class="hljs-built_in">printf</span>();             <span class="hljs-comment">/* 访问父类中的同名成员函数时，需要加作用域 */</span><br>    cout &lt;&lt; s1.m &lt;&lt; endl;<br>    cout &lt;&lt; s1.Father::m &lt;&lt; endl;   <span class="hljs-comment">/* 访问父类中的同名成员属性时，需要加作用域 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">son::printf<br>father::printf<br>200<br>100<br></code></pre></td></tr></table></figure><h3 id="继承中同名静态成员处理方式"><a href="#继承中同名静态成员处理方式" class="headerlink" title="继承中同名静态成员处理方式"></a>继承中同名静态成员处理方式</h3><p>静态成员：</p><ol><li><p>静态成员函数只能访问静态成员变量</p></li><li><p>静态成员属性：类内声明，类外初始化</p></li></ol><p>访问方式：</p><ol><li><p>通过对象访问</p></li><li><p>通过类名访问</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;father::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m;<br>&#125;;<br><br><span class="hljs-type">int</span> Father::m = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Father &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printf</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son::printf&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> m;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m = <span class="hljs-number">200</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Son s1;<br><br>    <span class="hljs-comment">// 通过对象访问</span><br>    s1.<span class="hljs-built_in">printf</span>();<br>    s1.Father::<span class="hljs-built_in">printf</span>();<br>    <span class="hljs-comment">// 通过类名访问</span><br>    Son::<span class="hljs-built_in">printf</span>();<br>    Son::Father::<span class="hljs-built_in">printf</span>();<br>    <span class="hljs-comment">// 通过对象访问</span><br>    cout &lt;&lt; s1.m &lt;&lt; endl;<br>    cout &lt;&lt; s1.Father::m &lt;&lt; endl;<br>    <span class="hljs-comment">// 通过类名访问</span><br>    cout &lt;&lt; Son::m &lt;&lt; endl;<br>    cout &lt;&lt; Son::Father::m &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">son::printf<br>father::printf<br>son::printf<br>father::printf<br>200<br>100<br>200<br>100<br></code></pre></td></tr></table></figure><h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><p>首先：强调一个概念</p><ol><li><p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p></li><li><p>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p></li><li><p>定义一个函数为纯虚函数，才代表函数没有被实现。</p></li></ol><p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    a-&gt;<span class="hljs-built_in">foo</span>();  <span class="hljs-comment">// 在这里，a 虽然是指向 A 的指针，但是被调用的函数 (foo) 却是 B 的!</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">B::foo() is called<br></code></pre></td></tr></table></figure><p>虽然 a 指向了 class A，但是调用的是 class B 中的 foo()</p><h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>语法：class 子类：继承方式 父类 1, 继承方式 父类 2 … </p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++ 开发中不建议使用多继承语法开发</strong></p><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li><p>两个派生类继承同一个基类</p></li><li><p>又有某个类同时继承两个派生类</p></li><li><p>这种继承被称为菱形继承，或者钻石分类</p></li></ol><h4 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h4><ol><li><p>羊继承了动物的数据，驼继承了动物的数据，当羊驼继承时，会产生二义性。</p></li><li><p>羊驼继承自动物的数据继承了两份</p></li></ol><p>第一种问题可以使用作用域解决；</p><p>第二种问题可以使用虚继承解决；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">/* 加 virtual 关键字，表示虚继承 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><br>&#125;;<br><br><span class="hljs-comment">/* 加 virtual 关键字，表示虚继承 */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span>: <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    SheepTuo t1;<br>    <span class="hljs-comment">//  t1.m_Age = 100; 继承了两份，产生二义性</span><br>    <span class="hljs-comment">// 当两个父类拥有相同的数据，需要加以作用域区分</span><br>    t1.Sheep::m_Age = <span class="hljs-number">100</span>;<br>    t1.Tuo::m_Age = <span class="hljs-number">200</span>;<br>    <span class="hljs-comment">//  菱形继承导致了数据有两份，造成资源浪费，使用虚继承，保证 m_Age 只有一份</span><br>    cout &lt;&lt; t1.Sheep::m_Age &lt;&lt; endl; <span class="hljs-comment">//vbptr, 虚拟指针指向 t1.m_Age </span><br>    cout &lt;&lt; t1.Tuo::m_Age &lt;&lt; endl;   <br>    cout &lt;&lt; t1.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>关键字：virtual </p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>多态分为两类：</p><ul><li><p>静态多态：函数重载、运算符重载属于静态多态，复用函数名</p></li><li><p>动态多态：派生类和虚函数实现运行时多态</p></li></ul><p>静态多态和动态多态的区别：</p><ul><li><p>静态多态的函数地址早绑定：编译阶段时确定函数地址</p></li><li><p>动态多态的韩式地址晚绑定：运行阶段时确定函数地址</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/* 虚函数 */</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;animal is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;cat is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;dog is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-comment">/* 动态多态的使用 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak_func</span><span class="hljs-params">(Animal &amp;animal)</span> </span>&#123;<br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Cat cat;<br>    Dog dog;<br><br>    <span class="hljs-built_in">speak_func</span>(cat);<br>    <span class="hljs-built_in">speak_func</span>(dog);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat is speaking<br>dog is speaking<br></code></pre></td></tr></table></figure><p>动态多态满足条件：</p><ol><li><p>有继承关系</p></li><li><p>子类重写父类的虚函数</p></li></ol><p>动态多态的使用：</p><ol><li>父类的指针或者引用指向子类对象</li></ol><p>多态带来的好处：</p><ol><li><p>组织结构清晰</p></li><li><p>可读性强</p></li></ol><p>重写：函数返回值类型，函数名，入参完全一致</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p><a href="https://zhuanlan.zhihu.com/p/75172640">虚函数表</a></p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的</p><p>纯虚函数语法：virtaul 返回值类型 函数名(参数列表) &#x3D; 0；</p><p>当类中有了纯虚函数，这个类也成为抽象类</p><p>抽象类的特点：</p><ol><li><p>无法实例化对象</p></li><li><p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* 抽象类：含有纯虚函数的类。纯虚函数：virtual 返回值类型 函数名（参数）= 0;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>: <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;son func&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>: <span class="hljs-keyword">public</span> Base &#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//  Base base; 报错: 抽象类无法实例化对象</span><br>    <span class="hljs-comment">//  new Base; 报错: 抽象类无法实例化对象</span><br>    <span class="hljs-comment">//  Son2 son2; 报错: 抽象类的子类必须重写父类中的纯虚函数, 否则还是抽象类</span><br>    Base *base = <span class="hljs-keyword">new</span> Son; <span class="hljs-comment">/* 编译正常， 运行正常 */</span><br>    base-&gt;<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">delete</span> base;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。</p><p>纯虚析构：需要声明也需要实现。</p><p>解决方法：将父类中的析构函数改为虚析构或者纯虚析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">Animal</span>() &#123;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Animal::Animal&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() &#123; <span class="hljs-comment">/* 父类的析构函数为虚函数时，父类指针在析构时才会调用子类的析构函数 */</span><br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Animal::~Animal&quot;</span> &lt;&lt; endl;<br>        &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>: <span class="hljs-keyword">public</span> Animal &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Sheep</span>(std::string name);<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    std::string *hello = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>        ​    cout &lt;&lt; *name &lt;&lt; <span class="hljs-string">&quot;Sheep is speaking&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        ~<span class="hljs-built_in">Sheep</span>() &#123;<br>        ​    <span class="hljs-keyword">if</span> (name) &#123;<br>        ​      <span class="hljs-keyword">delete</span> name;<br>        ​      name = <span class="hljs-literal">nullptr</span>;<br>        ​    &#125;<br>        ​    cout &lt;&lt; <span class="hljs-string">&quot;Sheep::~Sheep&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>        string *name = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br>Sheep::<span class="hljs-built_in">Sheep</span>(std::string name) &#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Sheep::Sheep&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>    Animal *sheep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Sheep</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    sheep-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> sheep;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>### 多态案例： 计算器类<br><br>分别使用普通写法和多态技术，设计实现两个操作数进行运算的计算器类<br><br>```c++<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* 多态案例一：实现计算器类</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> \* */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/* 普通写法 */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorNoraml</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    ​    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span> </span>&#123;<br>    ​      <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>    ​        <span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>    ​      &#125;<br><br>    ​      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>    ​        <span class="hljs-built_in">return</span> (m_Num1 &gt; m_Num2)? (m_Num1 - m_Num2) : (m_Num2 - m_Num1);<br>    ​      &#125;<br>    ​      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//      如果想扩展新的功能，需要修改源码</span><br>    <span class="hljs-comment">//      在真正开发中，提倡开闭原则: 对扩展进行开放, 对修改进行关闭</span><br>    ​    &#125;<br><br>    ​    <span class="hljs-type">int</span> m_Num1; <span class="hljs-comment">// 操作数一</span><br>    ​    <span class="hljs-type">int</span> m_Num2; <span class="hljs-comment">// 操作数二</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>  CalculatorNoraml test1;<br><br>  test1.m_Num1 = <span class="hljs-number">10</span>;<br>  test1.m_Num2 = <span class="hljs-number">8</span>;<br><br>  cout &lt;&lt; <span class="hljs-string">&quot;normal +:&quot;</span> &lt;&lt; test1.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br>  cout &lt;&lt; <span class="hljs-string">&quot;normal -:&quot;</span> &lt;&lt; test1.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">/* 多态写法 */</span><br><br><span class="hljs-comment">// 实现计算器的基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorAbstract</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>    <span class="hljs-type">int</span> m_Num1;<br>    <span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">// 实现加法类, 继承自基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>: <span class="hljs-keyword">public</span> CalculatorAbstract &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> m_Num2 + m_Num1;<br>        &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实现减法类, 继承自基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span>: <span class="hljs-keyword">public</span> CalculatorAbstract &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;<br>        ​    <span class="hljs-keyword">return</span> (m_Num1 &gt; m_Num2)? (m_Num1 - m_Num2) : (m_Num2 - m_Num1);<br>        &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">/* 多态使用条件</span><br><span class="hljs-comment">    \* 父类指针或者引用指向子类对象</span><br><span class="hljs-comment">    \* */</span><br><br>    <span class="hljs-comment">// 加法运算</span><br>    CalculatorAbstract * abc = <span class="hljs-keyword">new</span> Add;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;abstract +:&quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br><br>    abc = <span class="hljs-keyword">new</span> Sub;<br>    abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>    abc-&gt;m_Num2 = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;abstract -:&quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">normal +: 18<br>normal -:2<br>abstract +: 18<br>abstract -: 2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust代码 嵌入到 rt-thread</title>
    <link href="/2021/09/01/rust%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2021/09/01/rust%20%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Rust-是什么"><a href="#Rust-是什么" class="headerlink" title="Rust 是什么"></a>Rust 是什么</h2><p>Rust 是一门赋予每个人 构建可靠且高效软件能力的语言。</p><ul><li>高性能：速度惊人且内存利用率极高</li><li>可靠性：在编译期就能消除各种内存错误</li><li>生产力：出色的文档，友好的编译器和清晰的错误提示信息</li></ul><h2 id="为什么要用-Rust-进行嵌入式开发"><a href="#为什么要用-Rust-进行嵌入式开发" class="headerlink" title="为什么要用 Rust 进行嵌入式开发"></a>为什么要用 Rust 进行嵌入式开发</h2><p>Rust 的设计理念：既要安全，也要高性能。Rust 的设计理念完全是嵌入式开发所需要的。</p><p>嵌入式软件在运行过程中出现问题，大部分是由于内存引起的。Rust 语言可以说是一门面向编译器的语言。在编译期间，就能够确保你安全地使用内存。</p><p>目前，嵌入式的主流开发语言还是 C 语言，不能上来就把底层的逻辑用 Rust 重新实现一遍。但是可以在 C 代码中嵌入 Rust 语言。</p><h2 id="C-调用-Rust"><a href="#C-调用-Rust" class="headerlink" title="C 调用 Rust"></a>C 调用 Rust</h2><p>在 C 代码中调用 Rust 代码，需要我们将 Rust 源代码打包为静态库文件。在 C 代码编译时，链接进去。</p><h3 id="创建-lib-库"><a href="#创建-lib-库" class="headerlink" title="创建 lib 库"></a>创建 lib 库</h3><ol><li><p>在 Clion 中使用 <code>cargo init --lib rust_to_c</code> 建立 lib 库。添加以下代码到 lib.rs 中，使用 Rust 语言计算两个整数的和：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![no_std]</span><br><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sum</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(_info:&amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> !&#123;<br>    <span class="hljs-keyword">loop</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 Cargo.toml 文件中添加以下代码，生成静态库文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[lib]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;sum&quot;</span><br><span class="hljs-attr">crate-type</span> = [<span class="hljs-string">&quot;staticlib&quot;</span>]<br><span class="hljs-attr">path</span> = <span class="hljs-string">&quot;src/lib.rs&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><ol><li><p>安装 armv7 target:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">rustup <span class="hljs-keyword">target</span> add armv7a-<span class="hljs-keyword">none</span>-eabi<br></code></pre></td></tr></table></figure></li><li><p>生成静态库文件：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">PS C:\Users\LiuKang\Desktop\RUST\rust_to_c&gt; cargo build --target=armv7a-none-eabi --release --verbose<br>       Fresh rust_to_c v0.<span class="hljs-number">1.0</span> (C:\Users\LiuKang\Desktop\RUST\rust_to_c)<br>    Finished release [optimized] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s<br></code></pre></td></tr></table></figure></li></ol><h3 id="生成头文件"><a href="#生成头文件" class="headerlink" title="生成头文件"></a>生成头文件</h3><ol><li><p>安装 [cbindgen](<a href="https://github.com/eqrion/cbindgen">eqrion&#x2F;cbindgen: A project for generating C bindings from Rust code (github.com)</a>), cbindgen 从 rust 库生成 C&#x2F;C++ 11 头文件：</p> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">cargo install <span class="hljs-comment">--force cbindgen</span><br></code></pre></td></tr></table></figure></li><li><p>在项目文件夹下新建文件 <code>cbindgen.toml</code> 文件：</p></li><li><p>生成头文件：</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cbindgen <span class="hljs-attr">--config</span> cbindgen<span class="hljs-selector-class">.toml</span> <span class="hljs-attr">--crate</span> rust_to_c <span class="hljs-attr">--output</span> sum.h<br></code></pre></td></tr></table></figure></li></ol><h3 id="调用-Rust-库文件"><a href="#调用-Rust-库文件" class="headerlink" title="调用 Rust 库文件"></a>调用 Rust 库文件</h3><ol><li><p>将生成的<code>sum.h</code> 以及 <code>sum.a</code> 文件放入 <code>rt-thread\bsp\qemu-vexpress-a9\applications</code> 目录下</p></li><li><p>修改 SConscript 文件，添加静态库:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust">from building import *<br><br>cwd     = <span class="hljs-title function_ invoke__">GetCurrentDir</span>()<br>src     = <span class="hljs-title function_ invoke__">Glob</span>(&#x27;*.c&#x27;) + <span class="hljs-title function_ invoke__">Glob</span>(&#x27;*.cpp&#x27;)<br>CPPPATH = [cwd]<br><br>LIBS = [<span class="hljs-string">&quot;libsum.a&quot;</span>]<br>LIBPATH = [<span class="hljs-title function_ invoke__">GetCurrentDir</span>()]<br><br>group = <span class="hljs-title function_ invoke__">DefineGroup</span>(<span class="hljs-symbol">&#x27;Applications</span>&#x27;, src, depend = [&#x27;&#x27;], CPPPATH = CPPPATH, LIBS = LIBS, LIBPATH = LIBPATH)<br><br><span class="hljs-title function_ invoke__">Return</span>(<span class="hljs-symbol">&#x27;group</span>&#x27;)<br></code></pre></td></tr></table></figure></li><li><p>在 main 函数中调用 sum 函数, 并获取返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust">#include &lt;stdint.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;rtthread.h&gt;<br>#include <span class="hljs-string">&quot;sum.h&quot;</span><br><br>int <span class="hljs-title function_ invoke__">main</span>(void)<br>&#123;<br>    int32_t tmp;<br><br>    tmp = <span class="hljs-title function_ invoke__">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-title function_ invoke__">printf</span>(<span class="hljs-string">&quot;call rust sum(1, 2) = %d\n&quot;</span>, tmp);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 env 环境下，使用 scons 编译工程：</p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs rust">   LiuKang@DESKTOP-<span class="hljs-number">538</span>H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9<br>   $ scons -j6<br>   scons: Reading SConscript files ...<br>   scons: done reading SConscript files.<br>   <br>   scons: warning: you <span class="hljs-keyword">do</span> not seem to have the pywin32 extensions installed;<br>   <span class="hljs-title function_ invoke__">parallel</span> (-j) builds may not work reliably with open Python files.<br>   File <span class="hljs-string">&quot;D:\software\env_released_1.2.0\env\tools\Python27\Scripts\scons.py&quot;</span>, line <span class="hljs-number">204</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>   scons: Building targets ...<br>   scons: building associated VariantDir targets: build<br>   LINK rtthread.elf<br>   arm-none-eabi-objcopy -O binary rtthread.elf rtthread.bin<br>   arm-none-eabi-size rtthread.elf<br>  text    data     bss     dec     hex filename<br><span class="hljs-number">628220</span>    <span class="hljs-number">2148</span>   <span class="hljs-number">86700</span>  <span class="hljs-number">717068</span>   af10c rtthread.elf<br>   scons: done building targets.<br>   <br>   LiuKang@DESKTOP-<span class="hljs-number">538</span>H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9<br>   $ qemu.bat<br>   WARNING: Image format was not specified <span class="hljs-keyword">for</span> <span class="hljs-symbol">&#x27;sd</span>.bin&#x27; and probing guessed raw.<br>Automatically detecting the format is dangerous <span class="hljs-keyword">for</span> <span class="hljs-title class_">raw</span> images, write operations on block <span class="hljs-number">0</span> will be restricted.<br>Specify the <span class="hljs-symbol">&#x27;raw</span>&#x27; format explicitly to remove the restrictions.<br>   <br>\ | /<br>   - RT -     Thread Operating System<br>/ | \     <span class="hljs-number">4.0</span>.<span class="hljs-number">4</span> build Jul <span class="hljs-number">28</span> <span class="hljs-number">2021</span><br><span class="hljs-number">2006</span> - <span class="hljs-number">2021</span> Copyright by rt-thread team<br>   lwIP-<span class="hljs-number">2.1</span>.<span class="hljs-number">2</span> initialized!<br>   [I/sal.skt] Socket Abstraction Layer initialize success.<br>   [I/SDIO] SD card capacity <span class="hljs-number">65536</span> KB.<br>   [I/SDIO] switching card to high speed failed!<br>   call rust <span class="hljs-title function_ invoke__">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br>   msh /&gt;<br></code></pre></td></tr></table></figure><h3 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h3><ol><li><p>在 lib.rs 文件中，使用 rust 语言实现加减乘除运算：</p>   <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![no_std]</span><br><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">subtract</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a - b<br>&#125;<br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">multiply</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a * b<br>&#125;<br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a / b<br>&#125;<br><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(_info:&amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> !&#123;<br>    <span class="hljs-keyword">loop</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成库文件和头文件并放在 application 目录下</p></li><li><p>使用 scons 编译，链接时报错，在 rust github 仓库的 issues 中找到了 <a href="https://github.com/rust-lang/compiler-builtins/issues/353">解决办法</a> ：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">LINK rtthread.elf<br>d:/software/env_released_1.<span class="hljs-number">2.0</span>/env/tools/gnu_gcc/arm_gcc/mingw/bin/../lib/gcc/arm-none-eabi/<span class="hljs-number">5.4</span>.<span class="hljs-number">1</span>/armv7-ar/thumb\libgcc.<span class="hljs-title function_ invoke__">a</span>(_arm_addsubdf3.o): In function `__aeabi_ul2d&#x27;:<br>(.text+<span class="hljs-number">0x304</span>): multiple definition of `__aeabi_ul2d&#x27;<br>applications\libsum.<span class="hljs-title function_ invoke__">a</span>(compiler_builtins-<span class="hljs-number">9</span>b744f6fddf5e719.compiler_builtins.<span class="hljs-number">20</span>m0qzjq-cgu.<span class="hljs-number">117</span>.rcgu.o):/cargo/registry/src/github.com-<span class="hljs-number">1</span>ecc6299db9ec823/compiler_builtins-<span class="hljs-number">0.1</span>.<span class="hljs-number">35</span>/src/float/conv.rs:<span class="hljs-number">143</span>: first defined here<br>collect2.exe: error: ld returned <span class="hljs-number">1</span> exit status<br>scons: *** [rtthread.elf] Error <span class="hljs-number">1</span><br>scons: building terminated because of errors.<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>rtconfig.py</code> 文件， 添加链接参数 <code>--allow-multiple-definition</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">DEVICE = &#x27; -march=armv7-a -marm -msoft-float&#x27;<br>CFLAGS = DEVICE + &#x27; -Wall&#x27;<br>AFLAGS = &#x27; -c&#x27; + DEVICE + &#x27; -x assembler-with-cpp -D__ASSEMBLY__ -I.&#x27;<br>LINK_SCRIPT = <span class="hljs-symbol">&#x27;link</span>.lds&#x27;<br>LFLAGS = DEVICE + &#x27; -nostartfiles -Wl,--gc-sections,-Map=rtthread.map,-cref,-u,system_vectors,--allow-multiple-definition&#x27;+\<br>                  &#x27; -T %s&#x27; % LINK_SCRIPT<br>   <br>CPATH = &#x27;&#x27;<br>LPATH = &#x27;&#x27;<br></code></pre></td></tr></table></figure></li><li><p>编译并运行 qemu：</p></li></ol><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sqf">   LiuKang@DESKTOP-<span class="hljs-number">538</span>H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9<br>   $ scons -j6<br>   scons: Reading SConscript files ...<br>   scons: done reading SConscript files.<br>   <br>   scons: warning: you <span class="hljs-keyword">do</span> <span class="hljs-built_in">not</span> seem <span class="hljs-keyword">to</span> have the pywin32 extensions installed;<br>   parallel (-j) builds may <span class="hljs-built_in">not</span> work reliably <span class="hljs-keyword">with</span> open Python files.<br>   File <span class="hljs-string">&quot;D:\software\env_released_1.2.0\env\tools\Python27\Scripts\scons.py&quot;</span>, line <span class="hljs-number">204</span>, <span class="hljs-built_in">in</span> &lt;module&gt;<br>   scons: Building <span class="hljs-built_in">targets</span> ...<br>   scons: building associated VariantDir <span class="hljs-built_in">targets</span>: build<br>   LINK rtthread.elf<br>   arm-none-eabi-objcopy -O binary rtthread.elf rtthread.bin<br>   arm-none-eabi-<span class="hljs-built_in">size</span> rtthread.elf<br>  <span class="hljs-built_in">text</span>    data     bss     dec     hex filename<br><span class="hljs-number">628756</span>    <span class="hljs-number">2148</span>   <span class="hljs-number">86700</span>  <span class="hljs-number">717604</span>   af324 rtthread.elf<br>   scons: done building <span class="hljs-built_in">targets</span>.<br>   <br>   LiuKang@DESKTOP-<span class="hljs-number">538</span>H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9<br>   $ qemu.bat<br>   WARNING: <span class="hljs-built_in">Image</span> <span class="hljs-built_in">format</span> was <span class="hljs-built_in">not</span> specified <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;sd.bin&#x27;</span> <span class="hljs-built_in">and</span> probing guessed raw.<br>    Automatically detecting the <span class="hljs-built_in">format</span> is dangerous <span class="hljs-keyword">for</span> raw images, write operations on block <span class="hljs-number">0</span> will be restricted.<br>    Specify the <span class="hljs-string">&#x27;raw&#x27;</span> <span class="hljs-built_in">format</span> explicitly <span class="hljs-keyword">to</span> remove the restrictions.<br>   <br>\ | /<br>   - RT -     Thread Operating System<br>/ | \     <span class="hljs-number">4.0</span>.<span class="hljs-number">4</span> build Jul <span class="hljs-number">28</span> <span class="hljs-number">2021</span><br><span class="hljs-number">2006</span> - <span class="hljs-number">2021</span> Copyright by rt-thread team<br>   lwIP-<span class="hljs-number">2.1</span>.<span class="hljs-number">2</span> initialized!<br>   [I/sal.skt] Socket Abstraction Layer initialize success.<br>   [I/SDIO] SD card capacity <span class="hljs-number">65536</span> KB.<br>   [I/SDIO] switching card <span class="hljs-keyword">to</span> high <span class="hljs-built_in">speed</span> failed!<br>   <span class="hljs-built_in">call</span> rust sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br>   <span class="hljs-built_in">call</span> rust subtract(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br>   <span class="hljs-built_in">call</span> rust multiply(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">4</span><br>   <span class="hljs-built_in">call</span> rust divide(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="Rust-调用-C"><a href="#Rust-调用-C" class="headerlink" title="Rust 调用 C"></a>Rust 调用 C</h2><p>可以 在 C 代码中调用 Rust，那么在 Rust 中也可以调用 C 代码。我们在  Rust 代码中调用 rt_kprintf 函数：</p><h3 id="修改-lib-rs-文件"><a href="#修改-lib-rs-文件" class="headerlink" title="修改 lib.rs 文件"></a>修改 lib.rs 文件</h3><pre><code class="hljs"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 导入的 rt-thread 函数列表</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">rt_kprintf</span>(format: *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>, ...);<br>&#125;<br><br><span class="hljs-meta">#[no_mangle]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-title function_ invoke__">rt_kprintf</span>(<span class="hljs-string">b&quot;this is from rust\n\0&quot;</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);<br>    &#125;<br>    a + b<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h3 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h3><pre><code class="hljs"><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust">cargo build --target=armv7a-none-eabi --release --verbose<br>   Compiling rust_to_c v0.<span class="hljs-number">1.0</span> (C:\Users\LiuKang\Desktop\RUST\rust_to_c)<br>     Running `rustc --<span class="hljs-keyword">crate</span>-name sum --edition=<span class="hljs-number">2018</span> src/lib.rs --error-format=json --json=diagnostic-rendered-ansi --<span class="hljs-keyword">crate</span>-<span class="hljs-keyword">type</span> <span class="hljs-title class_">staticlib</span> --emit=dep-info,link -C opt-level=<span class="hljs-number">3</span> -C embed-bitcode=no -C metadata=a<br><span class="hljs-number">0723</span>fa112c78339 -C extra-filename=-a0723fa112c78339 --out-dir C:\Users\LiuKang\Desktop\RUST\rust_to_c\target\armv7a-none-eabi\release\deps --target armv7a-none-eabi -L dependency=C:\Users\LiuKang\Desktop\RUS<br>T\rust_to_c\target\armv7a-none-eabi\release\deps -L dependency=C:\Users\LiuKang\Desktop\RUST\rust_to_c\target\release\deps`<br>    Finished release [optimized] <span class="hljs-title function_ invoke__">target</span>(s) <span class="hljs-keyword">in</span> <span class="hljs-number">0.11</span>s<br></code></pre></td></tr></table></figure></code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>复制 rust 生成的库文件到 application 目录下。</p><pre><code class="hljs"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">LiuKang@DESKTOP-538H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9                                                       <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">scons -j6</span>                                                                                                             <br>scons: Reading SConscript files ...                                                                                  <br>scons: done reading SConscript files.                                                                                                     <br>scons: warning: you do not seem to have the pywin32 extensions installed;                                                   <br>        parallel (-j) builds may not work reliably with open Python files.                                                  <br>File &quot;D:\software\env_released_1.2.0\env\tools\Python27\Scripts\scons.py&quot;, line 204, in &lt;module&gt;                            <br>scons: Building targets ...                                                                                                 <br>scons: building associated VariantDir targets: build                                                                        <br>LINK rtthread.elf                                                                                                           <br>arm-none-eabi-objcopy -O binary rtthread.elf rtthread.bin                                                                   <br>arm-none-eabi-size rtthread.elf                                                                                             <br>   text    data     bss     dec     hex filename                                                                            <br> 628812    2148   90796  721756   b035c rtthread.elf                                                                        <br>scons: done building targets.                                                                                               <br>                                                                                                                            <br>LiuKang@DESKTOP-538H6DE D:\repo\github\rt-thread\bsp\qemu-vexpress-a9                                                       <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">qemu.bat</span>                                                                                                                  <br>WARNING: Image format was not specified for &#x27;sd.bin&#x27; and probing guessed raw.                                               <br>         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.    <br>         Specify the &#x27;raw&#x27; format explicitly to remove the restrictions.                                                    <br>                                                                                                                            <br> \ | /                                                                                                                      <br>- RT -     Thread Operating System                                                                                          <br> / | \     4.0.4 build Jul 28 2021                                                                                          <br> 2006 - 2021 Copyright by rt-thread team                                                                                    <br>lwIP-2.1.2 initialized!                                                                                                     <br>[I/sal.skt] Socket Abstraction Layer initialize success.                                                                    <br>[I/SDIO] SD card capacity 65536 KB.                                                                                         <br>[I/SDIO] switching card to high speed failed!                                                                               <br>this is from rust                                                                                                           <br>call rust sum(1, 2) = 3                                                                                           <br>call rust subtract(2, 1) = 1                                                                                                <br>call rust multiply(2, 2) = 4                                                                                                <br>call rust divide(4, 2) = 2                                                                                     <br>msh /&gt;                                                                                                                      <br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu</title>
    <link href="/2021/01/06/rt-thread-qemu/"/>
    <url>/2021/01/06/rt-thread-qemu/</url>
    
    <content type="html"><![CDATA[<h2 id="RT-Thread-Studio-QEMU-Simulator-Introduction"><a href="#RT-Thread-Studio-QEMU-Simulator-Introduction" class="headerlink" title="RT-Thread Studio QEMU Simulator Introduction"></a>RT-Thread Studio QEMU Simulator Introduction</h2><p>Embedded software development depends on development boards, which can be simulated using virtual machines such as QEMU without a physical development board. QEMU is a virtual machine that supports cross-platform virtualization and can virtual many development boards. To facilitate the development of embedded applications without a development board, RT-Thread Studio provides a QEMU emulation debugger. This article focuses on emulation using the RT-Thread Studio QEMU emulator on the Windows platform.</p><h3 id="Create-Project"><a href="#Create-Project" class="headerlink" title="Create Project"></a>Create Project</h3><ol><li>Click <strong>File</strong> button and create RT-Thread project:</li></ol><p><img src="/img/qemu/new_prj.png" alt="new_prj"></p><ol start="2"><li>Project configuration, as shown in the figure below, select QEMU in the <strong>Adapter</strong> configuration TAB and configure the appropriate emulator:</li></ol><p><img src="/img/qemu/create_prj.png" alt="create_prj"></p><ol start="3"><li>Click the <strong>Finish</strong> button, and a new QEMU project will be created in the workspace.</li></ol><h3 id="Switch-Debugger-to-QEMU"><a href="#Switch-Debugger-to-QEMU" class="headerlink" title="Switch Debugger to QEMU"></a>Switch Debugger to QEMU</h3><p>If the current project is an old project or the debugger you are currently selecting is a debugger other than QEMU and you want to use QEMU, click the drop-down box to the right of the Download button and select QEMU:</p><p><img src="/img/qemu/switch_to_qemu.png" alt="switch_to_qemu"></p><p>If the current project has not configured QEMU, after selecting QEMU, the prompt of <strong>QEMU Hasn’t been Configured</strong> will pop up, click <strong>Yes</strong> to display the QEMU configuration interface, the detail configurations  will be described in the next section.</p><p><img src="/img/qemu/qemu1.png" alt="qemu1"></p><h3 id="QEMU-Configuration"><a href="#QEMU-Configuration" class="headerlink" title="QEMU Configuration"></a>QEMU Configuration</h3><p>Click <strong>Open Debugging Configuration</strong> to jump to the QEMU configuration interface, and the parameters can be configured as follows:</p><table><thead><tr><th align="center">Parameter</th><th align="center">command</th></tr></thead><tbody><tr><td align="center">Emulator</td><td align="center">-M</td></tr><tr><td align="center">Cpu Quantity</td><td align="center">-smp</td></tr><tr><td align="center">SD Card Memory</td><td align="center">-sd</td></tr><tr><td align="center">Don’t open grapgic windows</td><td align="center">-nographic</td></tr><tr><td align="center">Use TAP for network</td><td align="center">-net</td></tr><tr><td align="center">Extra Commands</td><td align="center">None</td></tr></tbody></table><p>After filling in the form, click <strong>OK</strong> button to save configuration. The default configuration is as follows:</p><p><img src="/img/qemu/dbg_cfg.png" alt="dbg_cfg"></p><h3 id="Simulation-Debugging"><a href="#Simulation-Debugging" class="headerlink" title="Simulation Debugging"></a>Simulation Debugging</h3><p>Under normal compilation conditions, the IDE will automatically start QEMU and open the serial port by clicking the mode button, and enter breakpoint debugging mode, where you can observe the output of each breakpoint step by step, or execute your own commands in the serial port.</p><p><img src="/img/qemu/print.png" alt="print"></p><h2 id="QEMU-Serial-Debugging"><a href="#QEMU-Serial-Debugging" class="headerlink" title="QEMU Serial Debugging"></a>QEMU Serial Debugging</h2><p>RT-Thread supports FinSH module, and users can use command operations in command line mode. You can view all supported commands by typing ‘help’ at the debugging terminal or by pressing the TAB key. As shown in the figure below, the left is the command, and the right is the command description. The previous step showed you how to start QEMU, and this step shows you how to debug QEMU user programs in a serial port.</p><p><img src="/img/qemu/shell.png" alt="shell"></p><h3 id="View-The-Current-Thread"><a href="#View-The-Current-Thread" class="headerlink" title="View The Current Thread"></a>View The Current Thread</h3><p>To view the current thread and information such as thread state and stack size, please enter the command <code>list_thread</code> :</p><p><img src="/img/qemu/list_thread.png" alt="list_thread"></p><h3 id="Check-The-Timer-Status"><a href="#Check-The-Timer-Status" class="headerlink" title="Check The Timer Status"></a>Check The Timer Status</h3><p>Enter the command <code>list_timer</code>  to view the status of the timer :</p><p><img src="/img/qemu/list_timer.png" alt="list_timer"></p><h3 id="Add-User-Commands"><a href="#Add-User-Commands" class="headerlink" title="Add User Commands"></a>Add User Commands</h3><ol><li>Users can use <code>MSH_CMD_EXPORT</code> to export the command to MSH:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hello_sample</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    &#123;<br>    rt_kprintf(<span class="hljs-string">&quot;hello, world!\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> RT_EOK;<br>&#125;<br>MSH_CMD_EXPORT(hello_sample, hello world);<br></code></pre></td></tr></table></figure><ol start="2"><li>After compilation, you can enter the custom command <code>hello_sample</code> at the terminal:</li></ol><p><img src="/img/qemu/hello_world.png" alt="hello_world"></p><h2 id="QEMU-Network-Communication"><a href="#QEMU-Network-Communication" class="headerlink" title="QEMU Network Communication"></a>QEMU Network Communication</h2><p>While the basics of QEMU are described above, here’s how to use the complex peripherals on QEMU. RT-Thread Studio QEMU supports network communication and enables QEMU to connect to the network by enabling LWIP.</p><h3 id="Basic-Function"><a href="#Basic-Function" class="headerlink" title="Basic Function"></a>Basic Function</h3><ol><li>Enable ETH; Click <strong>RT-Thread Settings</strong>, select <strong>Hardware</strong>, and select <strong>Enable Ethernet</strong> function:</li></ol><p><img src="/img/qemu/eth.png" alt="eth"></p><ol start="2"><li>Enable SAL; Select <strong>Components</strong> and Enable <strong>Socket Abstraction Layer</strong>:</li></ol><p><img src="/img/qemu/sal.png" alt="sal"></p><ol start="3"><li>Save Configuration; You can use the combined command <strong>Ctrl+Shift+S</strong>, or the following button to save the configuration:</li></ol><p><img src="/img/qemu/save.png" alt="save"></p><ol start="4"><li>Debugging; Click the <strong>compile</strong> button, and start debugging after the compilation is completed; Enter the <code>ifconfig</code> command in the terminal to query the IP address obtained by QEMU:</li></ol><p><img src="/img/qemu/ifconfig.png" alt="ifconfig"></p><h3 id="Advanced-Function"><a href="#Advanced-Function" class="headerlink" title="Advanced Function"></a>Advanced Function</h3><p>This section introduces the advanced function about ethernet of QEMU.</p><h4 id="IoT-Packages"><a href="#IoT-Packages" class="headerlink" title="IoT Packages"></a>IoT Packages</h4><p>Thanks to RT-Thread’s rich software package, Studio users can quickly develop the application layer instead of focusing on the underlying adaptation. Below is an example of using a package on QEMU.</p><ol><li>Open <strong>RT-Thread Setting</strong> and open <strong>WebClient</strong> software package to enable <strong>WebClient GET&#x2F;POST samples</strong>:</li></ol><p><img src="/img/qemu/web_client.png" alt="web_client"></p><ol start="2"><li><p>Save configuration;</p></li><li><p>Compile and start debugging;Terminal input command <code>web_get_test</code>, <code>web_post_test</code> to test QEMU network functionality:</p></li></ol><p><img src="/img/qemu/web_test.png" alt="web_test"></p><h4 id="Enable-TAP"><a href="#Enable-TAP" class="headerlink" title="Enable TAP"></a>Enable TAP</h4><p>The default QEMU configuration cannot use the ping command; Once TAP is on, QEMU can use the ping command.</p><ol><li>Install the <a href="https://tap-windows.updatestar.com/">TAP</a> network card  by default all the way:</li></ol><p><img src="/img/qemu/tap_install.png" alt="tap_install"></p><ol start="2"><li>Configure TAP network card; Open the <strong>Network Connections</strong> to change the adapter settings and rename the installed virtual network card to <strong>tap</strong>, as shown below:</li></ol><p><img src="/img/qemu/tap_rename.png" alt="tap_rename"></p><ol start="3"><li>Right click on the current network connection that can access the Internet (Ethernet is used in this paper), open the attribute -&gt; share, select the home network connection as tap, and click ok to complete the setting, as shown in the figure below : (if there is only one network card, there is no need to pull down to select the network card, as long as the box is checked to allow sharing)</li></ol><p><img src="/img/qemu/tap_share.png" alt="tap_share"></p><ol start="4"><li>Configure QEMU; Add TAP configuration and save configuration:</li></ol><p><img src="/img/qemu/TAP_NAME.png" alt="TAP_NAME"></p><ol start="5"><li>Compile, start debugging, and ping test. Enter the command <code>ping www.rt-thread.io</code>:</li></ol><p><img src="/img/qemu/tap_ping.png" alt="tap_ping"></p><h2 id="In-The-End"><a href="#In-The-End" class="headerlink" title="In The End"></a>In The End</h2><p>If you have any questions about Studio, please post them on the <a href="https://club.rt-thread.io/">forum</a> and Studio developers will be more than happy to answer them.</p><p><a href="https://www.rt-thread.io/download.html?download=Studio">RT-Thread | Download (rt-thread.io)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>rt-thread</tag>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rt-thread 线程管理</title>
    <link href="/2020/12/09/rt-thread%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2020/12/09/rt-thread%20%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="RT-Thread-线程管理"><a href="#RT-Thread-线程管理" class="headerlink" title="RT-Thread 线程管理"></a>RT-Thread 线程管理</h1><h2 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h2><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p><code>rt_thread_create/init()</code>。线程的创建分为动态线程和静态线程。静态线程的特点是，在编译时，线程的栈地址以及占空间是确定的。动态线程的栈空间是从动态堆内存中申请到的。</p><h2 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h2><p>栈是一种先进后出的数据结构。在进行线程切换时，需要有单独的栈空间来保存当前线程的信息：入参，线程中的局部变量，返回地址。根据栈指针（sp）的指向方式，线程栈分为满栈和空栈（递增栈和递减栈）。这里以 cortex-v7 为例，栈指针从高地址向低地址。</p><p><img src="/img/rt-thread/thread/image-20210830135244697.png" alt="image-20210830135244697"></p><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>使用接口 <code>rt_system_scheduler_init();</code> 对调度器进行初始化。</p><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><ol><li>获取最高优先级</li><li>判断当前线程的状态<ul><li>当前线程的优先级低于最高优先级</li><li>当前线程的优先级等于最高优先级</li><li>当前线程的优先级高于最高优先级</li></ul></li></ol><p>调度器会根据时间表，选择就绪态最高优先级的线程切换为运行态</p>]]></content>
    
    
    
    <tags>
      
      <tag>rt-thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github actions 的使用流程</title>
    <link href="/2020/11/07/Github%20actions%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/07/Github%20actions%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-CI-（CONTINUOUS-INTEGRATION）"><a href="#什么是-CI-（CONTINUOUS-INTEGRATION）" class="headerlink" title="什么是 CI （CONTINUOUS INTEGRATION）"></a>什么是 CI （CONTINUOUS INTEGRATION）</h2><p>在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和<a href="http://www.ttlsa.com/auto/">自动化</a>测试流进行验证。这样做是基于之前</p><p>持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主线之后的质量问题，对可能出现的一些问题进行预警</p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><blockquote><p>GitHub Actions makes it easy to automate all your software workflows, now with world-class CI&#x2F;CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.</p></blockquote><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="创建工作流程"><a href="#创建工作流程" class="headerlink" title="创建工作流程"></a>创建工作流程</h3><ul><li><p>从 GitHub 上的仓库，在 <code>.github/workflow</code> 目录中创建一个名为 <code>superlinter.yml</code> 的新文件。 更多信息请参阅“<a href="https://docs.github.com/cn/free-pro-team@latest/github/managing-files-in-a-repository/creating-new-files">创建新文件</a>”。</p></li><li><p>将以下 YAML 内容复制到 <code>superlinter.yml</code> 文件中。 <strong>注：</strong> 如果您的默认分支不是 <code>main</code>，请更新 <code>DEFAULT_BRANCH</code> 的值以匹配您仓库的默认分支名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Super-Linter</span><br><br><span class="hljs-comment"># Run this workflow every time a new commit pushed to your repository</span><br><span class="hljs-attr">on:</span> <span class="hljs-string">push</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-comment"># Set the job key. The key is displayed as the job name</span><br>  <span class="hljs-comment"># when a job name is not provided</span><br>  <span class="hljs-attr">super-lint:</span><br>    <span class="hljs-comment"># Name the Job</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Lint</span> <span class="hljs-string">code</span> <span class="hljs-string">base</span><br>    <span class="hljs-comment"># Set the type of machine to run on</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Checks out a copy of your repository on the ubuntu-latest machine</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>      <span class="hljs-comment"># Runs the Super-Linter action</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">Super-Linter</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">github/super-linter@v3</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">DEFAULT_BRANCH:</span> <span class="hljs-string">main</span><br>          <span class="hljs-attr">GITHUB_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>在仓库中提交工作流程文件会触发 <code>push</code> 事件并运行工作流程。</p></li></ul><h3 id="查看工作流程"><a href="#查看工作流程" class="headerlink" title="查看工作流程"></a>查看工作流程</h3><ul><li><p>在 GitHub 上，导航到仓库的主页面。</p></li><li><p>在仓库名称下，单击 <strong>Actions（操作）</strong>。</p><p><img src="https://docs.github.com/assets/images/help/repository/actions-tab.png" alt="主仓库导航中的操作选项卡"></p></li><li><p>在左侧边栏中，单击您想要查看的工作流程。</p><p><img src="https://docs.github.com/assets/images/help/repository/superlinter-workflow-sidebar.png" alt="左侧边栏中的工作流程列表"></p></li><li><p>从工作流程运行列表中，单击要查看的运行的名称。</p><p><img src="https://docs.github.com/assets/images/help/repository/superlinter-run-name.png" alt="工作流程运行的名称"></p></li><li><p>在左侧边栏中，单击 <strong>Lint code base（Lint 代码库）</strong>作业。</p><p><img src="https://docs.github.com/assets/images/help/repository/superlinter-lint-code-base-job.png" alt="Lint 代码库作业"></p></li><li><p>任何失败的步骤都会自动展开以显示结果。‘</p><p><img src="https://docs.github.com/assets/images/help/repository/super-linter-workflow-results-updated.png" alt="Super linter 工作流程结果"></p></li></ul><h2 id="高阶用法"><a href="#高阶用法" class="headerlink" title="高阶用法"></a>高阶用法</h2><h3 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Runs at 16:00 UTC on the 1st of every month</span><br><span class="hljs-attr">schedule:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span>  <span class="hljs-string">&#x27;0 16 1 * *&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">env:</span><br><span class="hljs-symbol">  SERVER:</span> production<br></code></pre></td></tr></table></figure><ul><li><p>在工作流程中使用 env：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">world</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">Hello</span> <span class="hljs-string">world</span> <span class="hljs-string">$FIRST_NAME</span> <span class="hljs-string">$middle_name</span> <span class="hljs-string">$Last_Name!</span><br>    <span class="hljs-attr">env:</span><br>      <span class="hljs-attr">FIRST_NAME:</span> <span class="hljs-string">Mona</span><br>      <span class="hljs-attr">middle_name:</span> <span class="hljs-string">The</span><br>      <span class="hljs-attr">Last_Name:</span> <span class="hljs-string">Octocat</span><br></code></pre></td></tr></table></figure></li><li><p>您也可以使用 <code>GITHUB_ENV</code>  设置工作流程中的以下步骤可以使用的环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">world1</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span>  <span class="hljs-string">&quot;TEST_ENV=true&quot;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">$GITHUB_ENV</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">world2</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">$TEST_ENV</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="使用多个-Python"><a href="#使用多个-Python" class="headerlink" title="使用多个 Python"></a>使用多个 Python</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">strategy:</span><br>  <span class="hljs-attr">matrix:</span><br>    <span class="hljs-attr">python:</span> [<span class="hljs-number">3.5</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">3.7</span>, <span class="hljs-number">3.8</span>]<br><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">python-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.python</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="使用多个操作系统"><a href="#使用多个操作系统" class="headerlink" title="使用多个操作系统"></a>使用多个操作系统</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">runs-on:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.os</span> <span class="hljs-string">&#125;&#125;</span><br><span class="hljs-attr">strategy:</span><br>  <span class="hljs-attr">matrix:</span><br>    <span class="hljs-attr">os:</span> [<span class="hljs-string">ubuntu-16.04</span>, <span class="hljs-string">ubuntu-18.04</span>]<br>    <span class="hljs-attr">python:</span> [<span class="hljs-number">3.5</span>, <span class="hljs-number">3.6</span>, <span class="hljs-number">3.7</span>, <span class="hljs-number">3.8</span>]<br><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">python-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.python</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="在矩阵中使用环境变量"><a href="#在矩阵中使用环境变量" class="headerlink" title="在矩阵中使用环境变量"></a>在矩阵中使用环境变量</h4><p>Example: <a href="https://github.com/RT-Thread/rt-thread/blob/master/.github/workflows/action.yml">RT-Thread action</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">strategy:</span><br><span class="hljs-comment"># 设置为 true 时，如果任何 matrix 作业失败，GitHub 将取消所有进行中的作业。 默认值：true</span><br>  <span class="hljs-attr">fail-fast:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">matrix:</span><br>   <span class="hljs-attr">legs:</span><br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;CME_M7&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;apollo2&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;asm9260t&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;at91sam9260&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125; <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;allwinner_tina&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125; <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;efm32&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125; <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;gd32e230k-start&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125; <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;gd32303e-eval&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;         <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;gd32450z-eval&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;gkipc&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;imx6sx/cortex-a9&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125; <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;imxrt/imxrt1052-atk-commander&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;  <br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;imxrt/imxrt1052-fire-pro&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;imxrt/imxrt1052-nxp-evk&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;lm3s8962&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br>     <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">&quot;lm3s9b9x&quot;</span>, <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">&quot;sourcery-arm&quot;</span>&#125;<br><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Python</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-python@master</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">python-version:</span> <span class="hljs-number">3.8</span><br>      <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Bsp</span> <span class="hljs-string">Scons</span> <span class="hljs-string">Compile</span><br>    <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">success()</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br>    <span class="hljs-attr">env:</span><br>      <span class="hljs-attr">RTT_BSP:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.legs.RTT_BSP</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">RTT_TOOL_CHAIN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.legs.RTT_TOOL_CHAIN</span> <span class="hljs-string">&#125;&#125;</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>      <span class="hljs-string">scons</span> <span class="hljs-string">-C</span> <span class="hljs-string">bsp/$RTT_BSP</span><br></code></pre></td></tr></table></figure><h3 id="if-语法"><a href="#if-语法" class="headerlink" title="if 语法"></a>if 语法</h3><p>Example: <a href="https://github.com/RT-Thread-Studio/sdk-index/blob/master/.github/workflows/action.yml">RT-ThreadStudio action</a></p><p>可以使用 <code>if</code> 条件阻止作业在条件得到满足之前运行。 可以使用任何支持上下文和表达式来创建条件</p><h4 id="主分支触发"><a href="#主分支触发" class="headerlink" title="主分支触发"></a>主分支触发</h4><p>检查触发工作流程的分支本仓库并且上一个步骤成功时才会执行，否则跳过该步骤：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate-Import-Compile</span><br>  <span class="hljs-attr">shell:</span> <span class="hljs-string">bash</span><br>  <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.ref</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;refs/heads/master&#x27;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">success()</span> <span class="hljs-string">&#125;&#125;</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>    <span class="hljs-string">cd</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="合并时触发"><a href="#合并时触发" class="headerlink" title="合并时触发"></a>合并时触发</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">if</span>: github<span class="hljs-selector-class">.event</span><span class="hljs-selector-class">.pull_request</span>.merged<br></code></pre></td></tr></table></figure><h2 id="Marketplace"><a href="#Marketplace" class="headerlink" title="Marketplace"></a>Marketplace</h2><p>你可以在 Github 的 Marketplace 发现很多 Actions, 将这些已经写好的 action 添加到你的 CI 文件中，会减少开发者的工作量</p><h4 id="Checkout-V2"><a href="#Checkout-V2" class="headerlink" title="Checkout V2"></a>Checkout V2</h4><p><a href="https://github.com/actions/checkout">链接</a></p><blockquote><p>This action checks-out your repository under <code>$GITHUB_WORKSPACE</code>, so your workflow can access it.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br></code></pre></td></tr></table></figure><h4 id="setup-python-V2"><a href="#setup-python-V2" class="headerlink" title="setup-python V2"></a>setup-python V2</h4><p><a href="https://github.com/actions/setup-python">链接</a></p><blockquote><p>This action sets up a Python environment for</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Python</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-python@master</span><br>  <span class="hljs-attr">with:</span><br>    <span class="hljs-attr">python-version:</span> <span class="hljs-number">3.8</span><br></code></pre></td></tr></table></figure><h4 id="Upload-Artifact-v2"><a href="#Upload-Artifact-v2" class="headerlink" title="Upload-Artifact v2"></a>Upload-Artifact v2</h4><p><a href="https://github.com/actions/upload-artifact">链接</a></p><blockquote><p>This uploads artifacts from your workflow allowing you to share data between jobs and store data once a workflow is complete.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">txt</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;hellowold&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">test.txt</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">Results</span><br>  <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.ref</span> <span class="hljs-type">!=</span> <span class="hljs-string">&#x27;refs/heads/master&#x27;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">success()</span> <span class="hljs-string">&#125;&#125;</span><br>  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/upload-artifact@v2</span><br>  <span class="hljs-attr">continue-on-error:</span> <span class="hljs-literal">True</span><br>  <span class="hljs-attr">with:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">check-report</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;&#125;/test.txt</span><br></code></pre></td></tr></table></figure><h4 id="file-existence-action"><a href="#file-existence-action" class="headerlink" title="file-existence-action"></a>file-existence-action</h4><p><a href="https://github.com/andstor/file-existence-action/">链接</a></p><blockquote><p>This is a GitHub Action to check for existence of files. It can be used for conditionally running workflow steps based on file(s) existence.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;File existence check&quot;</span><br><br><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>, <span class="hljs-string">pull_request</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">file_existence:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">file</span> <span class="hljs-string">existence</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">check_files</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">andstor/file-existence-action@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">files:</span> <span class="hljs-string">&quot;package.json, LICENSE, README.md&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">File</span> <span class="hljs-string">exists</span><br>        <span class="hljs-attr">if:</span> <span class="hljs-string">steps.check_files.outputs.files_exists</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;true&#x27;</span><br>        <span class="hljs-comment"># Only runs if all of the files exists</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">All</span> <span class="hljs-string">files</span> <span class="hljs-string">exists!</span><br></code></pre></td></tr></table></figure><h4 id="Close-Stale-Issues-and-PRs"><a href="#Close-Stale-Issues-and-PRs" class="headerlink" title="Close Stale Issues and PRs"></a>Close Stale Issues and PRs</h4><p><a href="https://github.com/actions/stale">链接</a></p><blockquote><p>Warns and then closes issues and PRs that have had no activity for a specified amount of time.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">&quot;Close stale issues&quot;</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">schedule:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;30 1 * * *&quot;</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">stale:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/stale@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">repo-token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">stale-issue-message:</span> <span class="hljs-string">&#x27;Message to comment on stale issues. If none provided, will not mark issues stale&#x27;</span><br>        <span class="hljs-attr">stale-pr-message:</span> <span class="hljs-string">&#x27;Message to comment on stale PRs. If none provided, will not mark PRs stale&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>actions</tag>
      
      <tag>ci</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
